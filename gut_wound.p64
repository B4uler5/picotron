picotron cartridge // www.picotron.net
version 2

:: gfx/
:: map/
:: sfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTAzIDEzOjI2OjEwIixtb2RpZmllZD0iMjAyNC0w
NS0yOCAyMjo0ODowMyIscmV2aXNpb249MTkwMl1dbHo0AHQMAAB-UgAA8xh7WzBdPXtibXA9cHh1
AEMgICAE-yD----zLGZsYWdzPTAscGFuX3gIAMx5PTAsem9vbT03fSw1AFUNHxcPEgcAnwwPFw8g
DxIPFwsAfmUNHxf-IA4FAB4NJQAPkwBhIw8gcQEfMXEBFvYBEa8XTyCvFz8gDxevEg8XLwgAdxKv
IA8SLxcIABsXCAAAGAAaIAgAAY8AHxcMAAAACgAeIAwADzAA--8PANQCHw8EACgPEAMcIg8SzgMe
EtUDDwsAewqoAA_vAHgCiwAPhwTJUA8g8QGOJwD0CQ4NDxIB-QEBfgwODQ4BDf4BDQFuDA0ODQsA
DxYAElQPDf0BCxcAFfsXAB8LFgACcxsuDW4NLhsZALQLLg0ODU4NDg0uCzYAVD4Nbg0_OQAzG_0b
GAADQwABFQAu7hstAA9NABEZ7k0AJQ4NAgAD7AEfM_wBwyX3AewBQQf9AQfsARAHwAERBw4BBAsA
DxYAEgHsAQQXABX7FwAfCxYAAgPsAQMZAAefAQQ2AAKfAQMgADMb7RsYAANDAAEVAC7uGy0AD00A
ERnuTQAvDg3sASUf8AQKHV8QEATw8DEACxw5ZQCh-xcSryA-F88gL7MBEY_3AQE4BgPLAX8fF88g
HxfvCAAgD1AAAyIvF3AAM-8XJCgCDwQAADIvF9_RAA8cAAIATQARv00Amf8XAP8gAC8XnxYAAm8A
EX8MAAJKAFO-IP8XBAUABBIAGR8yAAAQAD--IAAJACAIRgAKeAB-PxefIP8XEpIBDA-HC09EDR8X
AQYAQAw9-gwXBQ8GAGAuDS3ZBg8KAQoI9gEMBADxDP8XA60_DyCtHB4NoQ0MDgwNoQ0PEgwOAawB
LQQAE60EADOsASwEADUNDA0GADUMDQwGAA8YAP0-HQwNAgAKD8UBDA8VCk0RAUgAAgYAB10CDwYA
YD8t-g0MAQwP0gUKDzQAeQ86BiQRj_MEFT_VBR1vBwUCDAAACAATr2UFHy8MACAIXAACFAA3LxeP
xQVRDyDvF7_EABOvHwQAKABTfxdPIC8QADMPF78IAASsAAABCQIQAAQwABUfDAAVbwwAFw-MAAZA
ABdvDAADewYLOAAX3ywAtP8XCW8gLxf-IAMvIgBkEv8gAQ8SMwA--yAFCQAFCywABUYANv8XCcUA
NP8XBG4AUU8gPxfvkgARvzwAGc_6AAFQABsXEAADJAAADAAXPxwAFD-EBwFtBR8RHQILHjVOAg8b
A1UPgwPpD2UAgw_ZACYPMQBPDywBsg40AA-_ABQPMQD------30f8jEAHS--HMUAHg8xAP------
--------1fQVQK8XIB6YDhAOuA4ADsgOAA4YDyAIDRgNCA0oHjgNOA04HigNEAAR2AIAMTgNCAIA
ECgtAAUMAABBAL8gDpgOQB5YHnBeQIYAPDUoDxiIALMIHB6oLB6YPB6ITIwANQwNLIwA-wUMDTwO
AA5IfA4QDiiMDiAenA5Aro0AIdNoLxgOEA54PQ4ADnhNkQDxAgwYDA0MLR44DBgdDD0eKAwI5Brx
AC0eSI0eOJ0eKK0eGB0ADQIANC0eCAsAMD0e3QIAL-4BhgAcdP8XAd8YHxcEAJMvGA8gDxgPIB8I
AIIvGB8XPxgPIAQADyAAAxffBAATPxgAFw8gAAQ0AAQEABc-MABP3xj-F7MAGrR3BgT-F2j-IGUf
FwUAyw8XAA7-IGMOIP5jEEsA8wAtNC4wNTk1MjM4MDk1MjRZAKItOC43MTkwNDc2BgACaAAfMuUC
HS8xMDIAYQE3AvELnx4OEA69DgAOzQ4ADh0HXQctHh0nPScdHi0MAAALAv4RDb8gDR4NDJcMDQ4A
Dg0MdwwNDhAOHXwdDiAOnQ5AHl0-Aw98ADGAHQIevRIerSJ-ABECfwATAn8AEBIuAM58Ig4QDj1y
DiAeDYIyAw_AABMgbx5FAHF9Mg4ADn1CgwD3CT0SByIeHScdEicSHi0HHTIHIh5Ngh49koUAIB4d
gwC-Hg0SfCIe0h7S-gF7AB1A-xcB0joAwx4iB1IHIh4SJzInEgwAABYAEAJqAO8CDZcNAh4SDXcN
Eh4ifWkAIS13RN4CDwUA-yQOFAQOggEP9wOf8gucDhAOvA4ADjw-IEwOAA4sDTwNPB48XTwePAoA
CAYAARYAIT8QqAb_BCwNOw0sDhAOPD08DiAOnA5AHlz-Aw_EADExLA8QCAAhHBsHAMMMKx48XTse
PA07DTuHAAAIAM88PUsOEA4siw4gHpsGBCWCfB8QDhAOjC2KABAMQQeyLAs8Cz0ePFs9HjwKAAcG
AOEsDVs9HhwdCz0LPR4MLQcAPk07TTIHDwsEFEDfEB8XBADxAE8QPyBPEB8XPxAPIDwOPwoAqV49
Hxc9DjwOPRsGABBeCgAkPQ4GAJ9NPk0b3Rvd_wFtAh8PMgCzAcYB9wWbDhAOuw4ADksvIEsOAA5b
DVseawQA-hxbDQkNSx5LDSkNOx47DUkNKw4ADisNSQ0bDhAOOw0pDSsOIA47LSsOQB5b0AIPgwAt
cUsDHmsNOxOFACEbI4YAETOGABMjhgAACAAAhgDPMw4QDisDLUMOIB6TzwIlcnsTDhAOiyOIACEL
M4kAYQtDHmsNUwQA4VsDDVMeSwMNCQ1DHjsDigAgKwODADEeGxMHACELMxUAX1MtQx7T0gIiydMe
0x5TLyBDHmMNUwQAEVN1ABFDXwARM2wAAgYAH0NxACkv8PAyALMBvAHxEZoOEA66DgAOyg4ADloP
IFoeWg0KDUoeag1aHtoeOg0KAgCVKh4qjRoeGg0IAgCzCg4ADhqNCg4QDiokAJ4aDiAOmg5AHlrN
Ag_LACm1Og8ZHmoNOhweqiyPAFksHiqNHI8AEQyPADEcDgCPABEM7gw_EA4q3QwPjwAYcHofGQ4Q
DoqlBSKKPZMA8QIKTR5aDAoMTR5qDF0eWn0eOqUnAN8MdSqMHR4aDAgCAJUNHhoNjB0eCi0iAA_u
BSY0GR8XBAD3Am8ZDyBfGR8XXxkPIA8ZDyBPFAAAIAATPxgABAQA9AMvGR8XLxmPIB8ZHxcfGQ8g
CA4CABEPGgAgjh3uBQIxLW8tHN0c3fwNA_v1CpcOEA63DgAOVwhXDgAORyhHHlcoRx5HSDcEAAAQ
ABFnHgARtywAfiAOlw5AHlf0Ag9yACzwBycPEh5HSBcdHkdIBy0eVygHPR5nCAdlDyBnXS8Av20O
EA43fQ4gHgeN4AIlgXcfEg4QDoctfgAhFz1-AJVNHlcoTR5HSD0EAP8ANx0oTR4nPQhdHhe9HgfN
xwInMBIfFwQAoG8SCF4fF14oTh0EADVOSD4EAAAQAFJuCF4d3gIAH-2LAiAPMgD---8L-xEICAQg
FlAXQA8cDxAfHCAOLxAeEB4NLhAXDScQXhBeAE0AHvIEHyBQBQ8VQAUuIAUOBy4QBSceEAkAAQUA
H05RAB-yAhZABhAGYAYQFxAGIAcABxAHBgAQAAIATxcgB1BRAB3-C0AoMDggBygPGBAnCA4QNwYQ
NwYgJwYwFwZAnQEfDzIA--------xfsDEgQwfxdgDnEOQA6RDiAOsQ4QBADwCSAOAX8TAQ4wDg8V
DxNRDQ8VDiAOHAFdAWUPYCx9LB4sfVEc-w8cfRwOIA4NAV0BDQ5ADiEeIQ5QDi8RHisOYC4QLjCT
AGRBLxYOEJQAMBsOMJQAIB5AlAAfKpQAty-wBJUACUARfxMRmAAyDVENmQBAAV0BDJcAH328AQBC
HgFdAYwAHyuMAK0ONwMPMgBxD0ICEFCRDjAOnzkCAJkcx90e3Q4ADr0OIB5xHlIDHiyeAQ98AEUQ
nawCOB5xHKkCHyt-AKIPnAILD3sBDA51AQ93AIoOzAIPMgBxCwMC8AARHxYBTREOEA4tDyA9DC0J
ABIMCAAwAZ0BLwQQfS4EMRFdESwEcXELDiAOK1E5GbAdHxgLHTseKy0KLYYbbBsdCBsdKyUDHimw
AQ_jAFmhCA8Yax4rLQgKW6IAMAo7PckCGB3JAg_iAMYv8AToAU8PngA_Mh0PIIQ-GB2iACMNDJk-
D6oAMQ_TA38PMgAfD4ACKRETMwFwDxULClEKCzYa0CodHxgKHToeKi0JLTq3GbgdCBodKg4gDgtx
C0MKHifqAQ_qAFYhCxqpANIIDxgqCyoeKi0ICQoLrACpCSoLPQ4QDgthCzUDD60A0S-wBK4ALDQf
FQutAA8DAgoOowAP5wMyMwANAOcDFgDnAwB-KA_vAFNQPTEwfX0=
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTAzIDEzOjI2OjA5Iixtb2RpZmllZD0iMjAyNC0w
NS0yOCAyMjo0ODowMyJdXWx6NAAEAAAAAwAAADBuaWw=
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTAzIDEzOjI2OjEwIixtb2RpZmllZD0iMjAyNC0w
NS0yOCAyMjo0ODowMyIscmV2aXNpb249MTc3Nl1dbHo0AKwAAABqEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD-AF8xMDAwMgQAABM0CAAvMzCAAE8SOAcADwgAAQ_AAFEMdAAJCAAP
AAHNXzkwMDBhBAAIL2IwAQD----------------E8QsiKSxoaWRkZW49ZmFsc2UscGFuX3g9LTE4
OAsAo3k9LTQyMC45MTYBALI3LHRpbGVfaD0zMgoAEHcKAIB6b29tPTR9fQ==
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTAzIDEzOjI2OjA5Iixtb2RpZmllZD0iMjAyNC0w
NS0yOCAyMjo0ODowMyJdXWx6NAAEAAAAAwAAADBuaWw=
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTAzIDEzOjI2OjEwIixtb2RpZmllZD0iMjAyNC0w
NS0yOCAyMjo0ODowMyIscmV2aXNpb249MTY2Nl1dbHo0AKkAAACSFwAA-yxweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8AD--w-wEA6-8n0gEQBg8g
EAEgASAB8AACEAIMEAEgDyEgATAPQPDDDygP--DGD-gKD-8PgA-3Dw0B8AkBEAYMMAD------70f
-wEArL-ID0AADUD--7DwcAoA--------------------hFD-sPD-OQ==
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTAzIDEzOjI2OjA5Iixtb2RpZmllZD0iMjAyNC0w
NS0yOCAyMjo0ODowMyJdXWx6NAAEAAAAAwAAADBuaWw=
:: character.lua
--[[pod_format="raw",created="2024-05-05 22:21:00",modified="2024-05-28 22:48:03",revision=1718]]
include './types.lua'
include './collision.lua'

--object, start frame,
--num frames, speed, flip
function animate_character(o,sf,nf,sp,fl)
	if(not o.a_ct) o.a_ct=0
	if(not o.a_st) o.a_st=0
	o.a_ct+=1
	if(o.a_ct%(30/sp)==0) then
	 o.a_st+=1
	 if(o.a_st==nf) o.a_st=0
	end

	o.a_fr=sf+o.a_st
	spr(o.a_fr,o.x,o.y)
end

character=entity:new({
    	x=160,
    	y=135,
    	max_width = 16,
    	max_height = 18,
    	col_point = { x=0, y=0 },
		s=255,
		health = 10,
		wound_health = 51,
		pain = 40,
		hunger = 40,
		thirst = 31,
		delirium = 50,
		idle_frames = {sf = 243, tf = 5, s = 0.8},
		
		state = "idle",
	update_vitals = function(self)
		if self.state == "idle" and self.health < 70 then
			last_update_move, current_update = 0, time_since(start_idle, time())
			if current_update != last_update_idle then
				last_update_idle = current_update
				self.health += 0.05
				self.hunger += 0.01
				self.thirst += 0.02
				if self.wound_health < 50 then
					self.wound_health += 0.01
				end
				if self.pain > 50 then
					self.pain -= 0.05
				end
			end
		end
		if self.state == "moving" then
			last_update_idle, current_update = 0, time_since(start_move, time())
			if current_update != last_update_move then
				last_update_move = current_update
				self.health -= 0.65
				self.wound_health -= 0.25
				self.pain += 0.1
				self.hunger += 0.1
				self.thirst += 0.1
			end
		end
		if self.health < 50 
			and self.wound_health < 50 
			and self.pain > 70 
			and self.hunger > 50 
			and self.thirst > 50 then
			last_update_idle, current_update = 0, time_since(start_move, time())
			if current_update != last_update_move then
				last_update_move = current_update
				self.delirium += 0.1
			end
		end
	end,
	move = function(self)
		_btn = btn()
		if _btn != button.none then
			spr(243, self.x, self.y)
			self.state, start_move = "moving", time()
			self.col_point = { x = (self.x+(self.max_width/2)), y = (self.y+(self.max_height/2)) }
			if _btn == button.down_right then
				self.col_point = { x = self.x+self.max_width, y = self.y+self.max_height}
				if collide(self,button.down_right) == false then
					self.y, self.x = self.y + 0.45, self.x + 1
				end
			elseif _btn == button.up_left then
				self.col_point = { x = self.x, y = self.y}
				if collide(self,button.up_left) == false then
					self.y, self.x = self.y - 0.45, self.x - 1
				end
			elseif _btn == button.up_right then
				self.col_point = { x = self.x+self.max_width, y = self.y }
				if collide(self,button.up_right) == false then
					self.y, self.x = self.y - 0.50, self.x + 1
				end
			elseif _btn == button.down_left then
				self.col_point = { x = self.x, y = self.y+self.max_height}
				if collide(self,button.down_left) == false then
					self.y, self.x = self.y + 0.50, self.x - 1
				end
			elseif _btn == button.right then
				self.col_point = { x = self.x+self.max_width, y = self.y+(self.max_height/2)}
				if collide(self,button.right) == false then
					self.x = self.x + 1
				end
			elseif _btn == button.left then
				self.col_point =  { x = self.x, y = self.y+(self.max_height/2)}
				if collide(self,button.left) == false then
					self.x = self.x - 1
				end
			elseif _btn == button.down then
				self.col_point = { x = self.x+(self.max_width/2), y = self.y+self.max_height}
				if collide(self,button.down) == false then
					self.y = self.y + 1
				end
			elseif _btn == button.up then
				self.col_point = { x = self.x+(self.max_width/2), y = self.y}
				if collide(self,button.up) == false then
					self.y = self.y - 1
				end
			end
		else
			self.state = "idle"
			start_idle = time()
			animate_character(self,243,4,0.5)
		end
	end,
})

:: collision.lua
--[[pod_format="raw",created="2024-05-17 20:59:47",modified="2024-05-28 22:48:03",revision=717]]
include './types.lua'
include './util.lua'

function tile_collide(o,d,r,f)
	r = r or 0
	f = f or 0		
	if d == button.up then
		circfill(o.col_point.x, o.col_point.y, 2, 8)
		if fget2(mget((o.col_point.x/_tile_size) + r, (o.col_point.y/_tile_size)) + r,f) then
			return true
		end
	end
	if d == button.down then
		circfill(o.col_point.x, o.col_point.y, 2, 8)
		if fget2(mget((o.col_point.x/_tile_size) + r, (o.col_point.y/_tile_size)) + r,f) then
			return true
		end
	end
	if d == button.left then
		circfill(o.col_point.x, o.col_point.y, 2, 8)
		if fget2(mget((o.col_point.x/_tile_size) + r, (o.col_point.y/_tile_size)) + r,f) then
			return true
		end
	end
	if d == button.right then
		circfill(o.col_point.x, o.col_point.y, 2, 8)
		if fget2(mget((o.col_point.x/_tile_size) + r, (o.col_point.y/_tile_size)) + r,f) then
			return true
		end
	end	
	if d == button.up_left then
		circfill(o.col_point.x, o.col_point.y, 2, 8)
		if fget2(mget((o.col_point.x/_tile_size) + r, (o.col_point.y/_tile_size)) + r,f) then
			return true
		end
	end
	if d == button.up_right then
		circfill(o.col_point.x, o.col_point.y, 2, 8)
		if fget2(mget((o.col_point.x/_tile_size) + r, (o.col_point.y/_tile_size)) + r,f) then
			return true
		end
	end
	if d == button.down_left then
		circfill(o.col_point.x, o.col_point.y, 2, 8)
		if fget2(mget((o.col_point.x/_tile_size) + r, (o.col_point.y/_tile_size)) + r,f) then
			return true
		end
	end
	if d == button.down_right then
		circfill(o.col_point.x, o.col_point.y, 2, 8)
		if fget2(mget((o.col_point.x/_tile_size) + r, (o.col_point.y/_tile_size)) + r,f) then
			return true
		end
	end
end

function collide(o,d)
	if tile_collide(o,d) then
		return true
	else
		return false
	end
end
:: inventory.lua
--[[pod_format="raw",created="2024-05-14 20:53:29",modified="2024-05-28 22:48:03",revision=973]]
include './types.lua'

slots=entity:new({
	name = "",
	item_type = 0,
	sprite = 0,
	amount = 0,
})

inventory=entity:new({
	max_width = 119,
	max_height = 6,
	open = false,
	slots={},
	update = function(self)
		if 		 ((_c_x-480+_m_x) > _c_x-360 
			and (_c_x-480+_m_x) < (_c_x-240+self.max_width)
			and (_m_y-_c_y) > _c_y
			and (_m_y+_c_y) < (_c_y + 6))
		then
			self.open = true
		end
		if self.open == true then
			spr(140,_c_x-360,_c_y)
			spr(140,(_c_x-240)+1,_c_y)
		else
			spr(132,_c_x-360,_c_y)
			spr(132,(_c_x-240)+1,_c_y)
		end		
	end
})

item_types = {
	medicine = 1,
	first_aid = 2,
	food = 3,
	drink = 4,
	junk = 5,
	useable = 6,
	special = 7,
	unique = 8,
}
:: main.lua
--[[pod_format="raw",created="2024-05-03 13:26:10",modified="2024-05-28 22:48:03",revision=2057]]
include './util.lua'
include './character.lua'
include './moodles.lua'
include './inventory.lua'
include './static_interactable.lua'

_debug_message = ""
_tile_size = 32

function _init()
    _w_w, _w_h = 480,270
    c=character:new({})
    m={moodles={}}
    i=inventory:new({})
end

function _draw()
	cls(0)
	camera(c.x - (_w_w/2),c.y - (_w_h/2))
	_c_x = c.x + (_w_w/2)
	_c_y = (c.y + (_w_h/2)) - 270
	_m_x, _m_y, _m_b, _m_w_x, _m_w_y = mouse()
	map()
	c:move()
	i:update()
	display_moodles(m,c)
	debug()
	interact_container(c)
end

function _update()
	c:update_vitals()
	interact_container(c)
end

function debug()
	print("debug_message: " .. _debug_message
			.. " c_x: " .. _c_x
			.. " c_y: " .. _c_y, _c_x-480, _c_y+10)
end
:: moodles.lua
--[[pod_format="raw",created="2024-05-07 21:40:35",modified="2024-05-28 22:48:03",revision=1352]]
include './types.lua'

moodle=entity:new({
	moodle = "none",
	sprite = 0,
	x = 0,
	y = 0,
})

function health_moodle(m,c)
	index = get_index(m.moodles, "health")
	current_moodle = nil
	if index != -1 then
		current_moodle = m.moodles[index]
	end
	current_sprite = nil
	if c.health < 70 and c.health >= 50 then
		new_sprite = moodle_sprites.health_1
	elseif c.health < 50 and c.health >= 30 then
		new_sprite = moodle_sprites.health_2
	elseif c.health < 30 and c.health >= 10 then
		new_sprite = moodle_sprites.health_3
	elseif c.health < 10 then
		new_sprite = moodle_sprites.health_4
	end
	if current_moodle == nil and new_sprite != nil then
		return moodle:new({moodle="health",sprite=new_sprite})
	elseif current_moodle != nil and current_moodle.sprite != new_sprite then
		del(m.moodles,current_moodle)
		return moodle:new({moodle="health",sprite=new_sprite})
	elseif current_moodle != nil and new_sprite == nil then
		del(m.moodles,current_moodle)
		return nil
	elseif current_moodle != nil and current_moodle.sprite == new_sprite then
		del(m.moodles,current_moodle)
		return moodle:new({moodle="health",sprite=new_sprite})
	end
	return nil
end

function wound_health_moodle(m,c)
	index = get_index(m.moodles, "wound_health")
	current_moodle = nil
	if index != -1 then
		current_moodle = m.moodles[index]
	end
	new_sprite = nil
	if c.wound_health < 70 and c.wound_health >= 50 then
		new_sprite = moodle_sprites.wound_health_1
	elseif c.wound_health < 50 and c.wound_health >= 30 then
		new_sprite = moodle_sprites.wound_health_2
	elseif c.wound_health < 30 and c.wound_health >= 10 then
		new_sprite = moodle_sprites.wound_health_3
	elseif c.wound_health < 10 then
		new_sprite = moodle_sprites.wound_health_4
	end
	if current_moodle == nil and new_sprite != nil then
		return moodle:new({moodle="wound_health",sprite=new_sprite})
	elseif current_moodle != nil and current_moodle.sprite != new_sprite then
		del(m.moodles,current_moodle)
		return moodle:new({moodle="wound_health",sprite=new_sprite})
	elseif current_moodle != nil and new_sprite == nil then
		del(m.moodles,current_moodle)
		return nil
	elseif current_moodle != nil and current_moodle.sprite == new_sprite then
		del(m.moodles,current_moodle)
		return moodle:new({moodle="wound_health",sprite=new_sprite})
	end
	return nil
end

function pain_moodle(m,c)
	index = get_index(m.moodles, "pain")
	current_moodle = nil
	if index != -1 then
		current_moodle = m.moodles[index]
	end
		new_sprite = nil
		if c.pain > 20 and c.pain < 30 then
			new_sprite = moodle_sprites.pain_1
		elseif c.pain > 30 and c.pain < 50 then
			new_sprite = moodle_sprites.pain_2
		elseif c.pain > 50 and c.pain < 70 then
			new_sprite = moodle_sprites.pain_3
		elseif c.pain > 70 then
			new_sprite = moodle_sprites.pain_4
		end
	if current_moodle == nil and new_sprite != nil then
		return moodle:new({moodle="pain",sprite=new_sprite})
	elseif current_moodle != nil and current_moodle.sprite != new_sprite then
		del(m.moodles,current_moodle)
		return moodle:new({moodle="pain",sprite=new_sprite})
	elseif current_moodle != nil and new_sprite == nil then
		del(m.moodles,current_moodle)
		return nil
	elseif current_moodle != nil and current_moodle.sprite == new_sprite then
		del(m.moodles,current_moodle)
		return moodle:new({moodle="pain",sprite=new_sprite})
	end
	return nil
end

function hunger_moodle(m,c)
	index = get_index(m.moodles, "hunger")
	current_moodle = nil
	if index != -1 then
		current_moodle = m.moodles[index]
	end
		new_sprite = nil
		if c.hunger > 20 and c.hunger < 30 then
			new_sprite = moodle_sprites.hunger_1
		elseif c.hunger > 30 and c.hunger < 50 then
			new_sprite = moodle_sprites.hunger_2
		elseif c.hunger > 50 and c.hunger < 70 then
			new_sprite = moodle_sprites.hunger_3
		elseif c.hunger > 70 then
			new_sprite = moodle_sprites.hunger_4
		end
	if current_moodle == nil and new_sprite != nil then
		return moodle:new({moodle="hunger",sprite=new_sprite})
	elseif current_moodle != nil and current_moodle.sprite != new_sprite then
		del(m.moodles,current_moodle)
		return moodle:new({moodle="hunger",sprite=new_sprite})
	elseif current_moodle != nil and new_sprite == nil then
		del(m.moodles,current_moodle)
		return nil
	elseif current_moodle != nil and current_moodle.sprite == new_sprite then
		del(m.moodles,current_moodle)
		return moodle:new({moodle="hunger",sprite=new_sprite})
	end
	return nil
end

function thirst_moodle(m,c)
	index = get_index(m.moodles, "thirst")
	current_moodle = nil
	if index != -1 then
		current_moodle = m.moodles[index]
	end
		new_sprite = nil
		if c.thirst > 20 and c.thirst < 30 then
			new_sprite = moodle_sprites.thirst_1
		elseif c.thirst > 30 and c.thirst < 50 then
			new_sprite = moodle_sprites.thirst_2
		elseif c.thirst > 50 and c.thirst < 70 then
			new_sprite = moodle_sprites.thirst_3
		elseif c.thirst > 70 then
			new_sprite = moodle_sprites.thirst_4
		end
	if current_moodle == nil and new_sprite != nil then
		return moodle:new({moodle="thirst",sprite=new_sprite})
	elseif current_moodle != nil and current_moodle.sprite != new_sprite then
		del(m.moodles,current_moodle)
		return moodle:new({moodle="thirst",sprite=new_sprite})
	elseif current_moodle != nil and new_sprite == nil then
		del(m.moodles,current_moodle)
		return nil
	elseif current_moodle != nil and current_moodle.sprite == new_sprite then
		del(m.moodles,current_moodle)
		return moodle:new({moodle="thirst",sprite=new_sprite})
	end
	return nil
end

function delirium_moodle(m,c)
	index = get_index(m.moodles, "delirium")
	current_moodle = nil
	if index != -1 then
		current_moodle = m.moodles[index]
	end
		new_sprite = nil
		if c.delirium > 20 and c.delirium <= 30 then
			new_sprite = moodle_sprites.delirium_1
		elseif c.delirium > 30 and c.delirium <= 50 then
			new_sprite = moodle_sprites.delirium_2
		elseif c.delirium > 50 and c.delirium <= 70 then
			new_sprite = moodle_sprites.delirium_3
		elseif c.delirium > 70 then
			new_sprite = moodle_sprites.delirium_4
		end
	if current_moodle == nil and new_sprite != nil then
		return moodle:new({moodle="delirium",sprite=new_sprite})
	elseif current_moodle != nil and current_moodle.sprite != new_sprite then
		del(m.moodles,current_moodle)
		return moodle:new({moodle="delirium",sprite=new_sprite})
	elseif current_moodle != nil and new_sprite == nil then
		del(m.moodles,current_moodle)
		return nil
	elseif current_moodle != nil and current_moodle.sprite == new_sprite then
		del(m.moodles,current_moodle)
		return moodle:new({moodle="delirium",sprite=new_sprite})
	end
	return nil
end

function display_moodles(m,c)
	m.moodles = {}
	h = health_moodle(m,c)
	if h != nil then
		add(m.moodles,h)
	end
	wh = wound_health_moodle(m,c)
	if wh != nil then
		add(m.moodles,wh)
	end
	p = pain_moodle(m,c)
	if p != nil then
		add(m.moodles,p)
	end
	hu = hunger_moodle(m,c)
	if hu != nil then
		add(m.moodles,hu)
	end
	t = thirst_moodle(m,c)
	if t != nil then
		add(m.moodles,t)
	end
	d = delirium_moodle(m,c)
	if d != nil then
		add(m.moodles,d)
	end
	
	current_y = 1
	for i, moodle in ipairs(m.moodles) do
		spr(moodle.sprite, _c_x-18, _c_y + current_y)
		current_y += 20
	end
end

function get_index(moodles, name)
	for i, m in ipairs(moodles) do
		if m.moodle == name then
			return i
		end
	end
	return -1
end

moodle_sprites={
	health_1 = 168,
	health_2 = 169,
	health_3 = 170,
	health_4 = 171,
	wound_health_1 = 160,
	wound_health_2 = 161,
	wound_health_3 = 162,
	wound_health_4 = 163,
	pain_1 = 128,
	pain_2 = 129,
	pain_3 = 130,
	pain_4 = 131,
	delirium_1 = 136,
	delirium_2 = 137,
	delirium_3 = 138,
	delirium_4 = 139,
	hunger_1 = 152,
	hunger_2 = 153,
	hunger_3 = 154,
	hunger_4 = 155,
	thirst_1 = 144,
	thirst_2 = 145,
	thirst_3 = 146,
	thirst_4 = 147,
}
:: static_interactable.lua
--[[pod_format="raw",created="2024-05-23 20:57:56",modified="2024-05-28 22:48:03",revision=447]]
include './types.lua'
include './collision.lua'
include './util.lua'

function interact_container(o)
	local current_cel = { x = o.col_point.x/_tile_size, y = o.col_point.y/_tile_size}
	local top_right = { x = current_cel.x + 1, y = current_cel.y - 1 }
	local top_left = { x = current_cel.x - 1, y = current_cel.y - 1 }
	local top = { x = current_cel.x, y = current_cel.y - 1 }
	local right = { x = current_cel.x + 1, y = current_cel.y }
	local left = { x = current_cel.x - 1, y = current_cel.y }
	local bottom_right = { x = current_cel.x + 1, y = current_cel.y + 1 }
	local bottom_left = { x = current_cel.x - 1, y = current_cel.y +1 }
	local bottom = { x = current_cel.x, y = current_cel.y + 1 }
	local current = { x = current_cel.x, y = current_cel.y }
	local cell = nil
	
	if fget2(mget(top_right.x, top_right.y), 1) then
		text_x = (o.col_point.x) + _tile_size
		text_y = (o.col_point.y) - _tile_size
		cell = top_right
	elseif fget2(mget(top_left.x, top_left.y), 1) then
		text_x = (o.col_point.x) - _tile_size
		text_y = (o.col_point.y) - _tile_size
		cell = top_left
	elseif fget2(mget(top.x, top.y), 1) then
		text_x = (o.col_point.x)
		text_y = (o.col_point.y) - _tile_size
		cell = top
	elseif fget2(mget(right.x, right.y), 1) then
		text_x = (o.col_point.x) + _tile_size
		text_y = (o.col_point.y)
		cell = right
	elseif fget2(mget(left.x, left.y), 1) then
		text_x = (o.col_point.x) - _tile_size
		text_y = (o.col_point.y)
		cell = left
	elseif fget2(mget(bottom_right.x, bottom_right.y), 1) then
		text_x = (o.col_point.x) + _tile_size
		text_y = (o.col_point.y) + _tile_size
		cell = bottom_right
	elseif fget2(mget(bottom_left.x, bottom_left.y), 1) then
		text_x = (o.col_point.x) - _tile_size
		text_y = (o.col_point.y) + _tile_size
		cell = bottom_left
	elseif fget2(mget(bottom.x, bottom.y), 1) then
		text_x = (o.col_point.x)
		text_y = (o.col_point.y) + _tile_size
		cell = bottom
	elseif fget2(mget(current.x,current.y), 1) then
		text_x = (o.col_point.x)
		text_y = (o.col_point.y)
		cell = current
	else
		text_x = nil
		text_y = nil
		cell = nil
	end
	if text_x and text_y and cell then 
		if mget(cell.x, cell.y) == 4 then
			s_d_cell = cell 
			mset(cell.x, cell.y, 5)
		end
	elseif s_d_cell then
		mset(s_d_cell.x, s_d_cell.y, 4)
	end
end
:: types.lua
--[[pod_format="raw",created="2024-05-06 22:22:02",modified="2024-05-28 22:48:03",revision=1343]]
class={
	new=
		function(self,tbl)
			tbl=tbl or {}
			setmetatable(tbl, {
				__index=self
				}
			)
			return tbl
		end,
}

entity=class:new({
	x=0,
	y=0,
})

button={
	up=4,
	down=8,
	left=1,
	right=2,
	down_right=10,
	up_left=5,
	up_right=6,
	down_left=9,
	none=0
}
:: until.lua
--[[pod_format="raw",created="2024-05-06 21:03:50",modified="2024-05-06 21:40:08",revision=95]]
function coalesce(a, b)
	if a == nil then
		return b
	else
		return a
	end
end

function time_since(start, current)
	return (flr(current) - flr(start))
end
:: util.lua
--[[pod_format="raw",created="2024-05-03 22:03:54",modified="2024-05-28 22:48:03",revision=1385]]
function coalesce(a, b)
	if a == nil then
		return b
	else
		return a
	end
end

function time_since(from, to)
	return flr(to) - flr(from)
end

function fget2(n, f)
	if f then
		return (fget(n)>>f)&1==1
	else
		return fget(n)
	end
end
:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTAzIDEzOjQ4OjQ3Iixtb2RpZmllZD0iMjAyNC0w
NS0yOCAyMjo0ODowMyIscnVudGltZT03LHdvcmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEj
NiIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0idXRpbC5sdWEjMTciLHdvcmtzcGFjZV9p
bmRleD0xfSx7bG9jYXRpb249ImNoYXJhY3Rlci5sdWEjOTQiLHdvcmtzcGFjZV9pbmRleD0xfSx7
bG9jYXRpb249ImNvbGxpc2lvbi5sdWEjMzkiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249
InR5cGVzLmx1YSMxMyIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ibW9vZGxlcy5sdWEj
MjI1Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJpbnZlbnRvcnkubHVhIzE1Iix3b3Jr
c3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzdGF0aWNfaW50ZXJhY3RhYmxlLmx1YSM1Iix3b3Jr
c3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7
bG9jYXRpb249Im1hcC8wLm1hcCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ic2Z4LzAu
c2Z4Iix3b3Jrc3BhY2VfaW5kZXg9NH19XV1sejQABAAAAAMAAAAwbmls
:: [eoc]
