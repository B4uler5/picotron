picotron cartridge // www.picotron.net
version 2

:: gfx/
:: map/
:: sfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTAzIDEzOjI2OjEwIixtb2RpZmllZD0iMjAyNC0w
Ni0wNSAyMzoyMToyOCIscmV2aXNpb249MjkxNl1dbHo0AE8TAADGYQAA8xh7WzBdPXtibXA9cHh1
AEMgICAE-yD----zLGZsYWdzPTAscGFuX3gIAMx5PTAsem9vbT03fSw1AFUNHxcPEgcAnwwPFw8g
DxIPFwsAfmUNHxf-IA4FAB4NJQAPkwBhIw8gcQEfMXEBFvYBEa8XTyCvFz8gDxevEg8XLwgAdxKv
IA8SLxcIABsXCAAAGAAaIAgAAY8AHxcMAAAACgAeIAwADzAA--8PANQCHw8EACgPEAMcIg8SzgMe
EtUDDwsAewqoAA_vAHgCiwAPhwT-WlAPIPEBjicA8Q8ODQ8SAf0BAX4MDg0OAR3uHQFuDA0ODQEN
-gENAW4VAAMLAA8WAAdUDw39AQsXABX7FwAfCxYAAnMbLg1uDS4bGQC0Cy4NDg1ODQ4NLgs2AFQ_
DW4NPjkAMxvtGxgAAUMAJQ4NAgADLgIfMy4CEf8KFhoEEPcBMAf-FwEHEAce7yAeBwAHDv0BDgcA
BVAPDf4BDA8AEfwPABkMDgBwHC0ObQ4tHBgAkC0ODQ5NDg0OLR8AYAw9Dm0OPQoANxzuHC8AKe0c
HQAPNQAGFu01AE-3BfAz4QAZTyAgBPA7CR1fEBAE8PAxAAscOWUAof8XEq8gPxfPIC9GAhGPSgIB
bwUDXgJ-HxfPIB8X7wgAIA9QAAMiLxdwADP-FyS7Ag8EAAAyLxffkQAPHAACAE0AEb9NAJn-FwD-
IAAvF58WAAJvABF-DAACSgBTvyD-FwQFAAQSABkfMgAAEAA--yAACQAgCEYACngAfz8XnyD-FxKS
AQsfNv4KT0QNHxcBBgBADD3_DL8DDwYAYC4NLRAGDwoBClYNDyANDgIAof0joU2hPQGuAS0EABOt
BAAzrgEuBAAAVQQEBgAAawQEBgAPGAD9Px0ODQIACg_nAQwPLglNEQFIAAIGAAc-Ag8GAGA-Lf4N
DAEc8g8BHe8gHQGtAQ0_DxduDD4NAZ4NAQ0uDA4MTgwODC4PACE_DBoAEK2cB5DBDP0BDAGt8QUZ
ABB_LABPDQENvgwAD8ndAZ0BTfER3QH9AAHPAUABDd4N6QEFAgARHRIAEt0YABEeAgAkLg0mAAAO
ABI_DgAQHQwAIE4NUQABFwBBXg3xAiIAEW4UACEdHnsAAkUAFY5BABKeCgAjHa4SAB__CAAPb-0A
Ad3xEBUFDA8MBwIPNABND0AHJBGP6QUVP5sGHW8NBgIMAAAIABOvawYfLwwAIAhcAAIUADcvF4-L
BlEPIO8Xv4QAE68rBwAoAFN-F08gLxAAMw8XvwgABKwAACoLAhAABDAAFR8MABVvDAAXD8wABkAA
F28MAAOBBws4ABffLAC0-xcJbyAvF-8gAy8iAGQS-yABDxIzAD--IAUJAAULLAAFRgA2-xcJxQA0
-xcEbgBRTyA-F__SABG-PAAZz7oAAVAAGxcQAAMkAAAMABc-HAAUP8oIEBdhAB8RjgklHzFOAgQP
swIgDzQAAw9oACkPNAB5D4MDIeEBXQFdAS0BzQENPyANAdAEAAgFFa4MADwPFQ4UACMMHhIAEQ7N
BBQ_GAAABABYDI4NAV1IABdxDAAuAV1iAAQQACBODdgFAo4A0A1OHQwuDfEDDU4cPg2PDQEuAC3u
DQgAEM0GABPhCgBDbg0MXhsAU24MDQxODAAVfhYAH_4IADtP-QEBzYwFHgHiACf9AW8BE_4IAAAE
ACBOLf8NBhAAZy4dLxMNDBIAkh0ODRwNHgwNTkwBkR0cDQweDC4MTmcBQgwNDgxXBgNoAUkeDA0M
owFILgwNDBAAGj4fABlOHQAf7gwADyT9AQsALvEDFAABKwAA8AAHpQELRAFkDS4dDxWODABDCx0L
fgwAJD4bFgAf7ggAD0-NAf0BFge0DzEAgAC2ArH9CBFNAQ3-IAYNEQIJM54dngoAZI4NHxMNjg0A
UAweDA0evQMCEABVzgwdHA0NADUNHB4NAGO_HT4MDR4NAGOuDRxODC0MAEEMfhwdpwmw-QccHS4N
8QkNHC7jASOtASwAAMgJFgwNAEZuDQwNDgBnLg0OHQwOEQAwHg0MeAAGEQAwDg0MhwAHEQApDC4Q
AABJAwgxAFkuDQwODBEAJwxODgAfjgwAFxTNCgAd4RIACygAP60BTdECDR81WwQAM70BrVoEE55O
AAGKAycdPg4ASB4dHxMQAABSBBhOEAABRwQKIgBKDB4MPiMAGm4gAAMPAACCAHANjg2RDA2BDwAh
-QMWACENfv8KEY6OATUuHQwNAACuBCMcjg4AUw4dDA0MBQEA2AQSvgsAMD0M3QgAIPEFDQA0nQF9
UgBPAQ1eDQwAGhB9HAFAfg3xBg0AIf0EFABPDf4CDQkAAE_dAf0EfwEODxwEIB81ugMeDzEAvgCo
Aok9Ad0BrQE9AaMQER2pASEdDgQABgIABQ4AEB0xABwOMAAACAAKMAAlDQ4CAA8yAAIAYgAV3TQA
VB0BPfEASQA8jQE9PwARbrQCBTkAARAJEA1WBwEXAAdGAAEVA0YMDQwOMQAAGAAjDR48BC8eDVsA
DR5uVAAZjUwAXx0OLQ4dSgAAWQ4tDi0OTAAGEgAITgAHQAAPUgAaBBAAFj1OAAKOA0D9ASGtuQny
Ah4dPh3hDT4NDxMdGx0ODRvdTwCxCw4bDg0bDQsODQvdBJMOCx0uHQseCx7tBFIeGy4bXgwADksJ
D-AEEQA2AE4BDe8gEQgPxwkcIA2uwAgFDAANIwAhDe6qBQ7GCA8IAEwPFwESD8EDHg_FBPVznQHt
AQ0fIPgFEs5-Aw8MAEEBaQAxHg3xVwgA_wQiDR7OEQGIAw8MAGQBhQVA8RH9D10WHA0FAC-9D3gC
DR80gwEeDzEA--_tH-IxAB0v-xzFAB4PMQD--------------9X0FUCvFyAemA4QDrgOAA7IDgAO
GA8gCA0YDQgNKB44DTgNOB4oDRAAEdgCADE4DQgCABAoLQAFDAAAQQC-IA6YDkAeWB5wXkCGADw1
KA8YiACzCBweqCwemDweiEyMADUMDSyMAP8FDA08DgAOSHwOEA4ojA4gHpwOQK6NACHTaC8YDhAO
eD0OAA54TZEA8QQMGAwNDC0eOAwYHQw9HigMCAwdEQDRSI0eOJ0eKK0eGB0ADQIANC0eCAsAMD0e
3QIAL-4BhgAcdP8XAd8YHxcEAJMvGA8gDxgPIB8IAIIvGB8XPxgPIAQADyAAAxffBAATPxgAFw8g
AAQ0AAQEABc-MABP3xj-F7MAGrR3BgT-F2j-IGUfFwUAvA8XAA7-IGMOIP5jtxHzAC00LjA1OTUy
MzgwOTUyNFkAoi04LjcxOTA0NzYGAAJoABkyaADRdBIEEP8UYCD_YgD_-wEAf04A-mIg-mAaEgwf
MisDHS8xMDIALwFLAvELnx4OEA69DgAOzQ4ADh0HXQctHh0nPScdHi0MAAAfAjANvyATHP4KlwwN
DgAODQx3DA0OEA4dfB0OIA6dDkAeXVMDD3wAMYAdAh69Eh6tIn8AEQJ-ABMCfwAQEi4AznwiDhAO
PXIOIB4NgkYDD4AAEyBvHkUAcX0yDgAOfUKDAPcJPRIHIh4dJx0SJxIeLQcdMgciHk2CHj2ShQAg
Hh2DAL8eDRJ8Ih7SHtL_AXsAHUD-FwHSOgDDHiIHUgciHhInMicSDAAAFgAQAmoA7wINlw0CHhIN
dw0SHiJ9aQAhIHdE8gIgjyDiKPMANgf_Agf_AR8X-mUdjg3_DwAcHQ4AX-1p-mUdAwCXjQ0ADf5j
DSD9vwMTOBkBTy01LjWlAwYfE6UDEEc1NC4zAQAEVwAZMBYALzM0xSAkD8MDNvILnA4QDrwOAA48
PyBMDgAOLA08DTwePF08HjwKAAgGAAEWACE-EIgG-gQsDTsNLA4QDjw9PA4gDpwOQB5cywMPhAAx
MSwPEAgAIRwbBwDDDCsePF07HjwNOw07hwAACADPPD1LDhAOLIsOIB6b0gMlgnwfEA4QDowtigAQ
DCEHsiwLPAs9HjxbPR48CgAHBgDhLA1bPR4cHQs9Cz0eDC0HAD5NO00SBw-XAxRA3xAfFwQA8QBP
ED8gTxAfFz8QDyA8Dj8KAKlePR8XPQ48Dj0bBgAQXgoAJD0OBgCPTT5NG90b3ft_AB4v8PAyALMB
xgH3BZsOEA67DgAOSy8gSw4ADlsNWx5rBAD_HFsNCQ1LHksNKQ07HjsNSQ0rDgAOKw1JDRsOEA47
DSkNKw4gDjstKw5AHlvQAg_DAC1xSwMeaw07E4UAIRsjhgARM4YAEyOGAAAIAACGAM8zDhAOKwMt
Qw4gHpPPAiVyexMOEA6LI4gAIQsziQBhC0Meaw1TBADhWwMNUx5LAw0JDUMeOwOKACArA4MAMR4b
EwcAIQszFQBfUy1DHtPSAiLJ0x7THlMvIEMeYw1TBAARU3UAEUNfABEzbAACBgAfQ3EAKS-w8DIA
swG8AfERmg4QDroOAA7KDgAOWg8gWh5aDQoNSh5qDVoe2h46DQoCAJUqHiqNGh4aDQgCALMKDgAO
Go0KDhAOKiQAnhoOIA6aDkAeWs0CD4sAKbU6Dxkeag06HB6qLI8AWSweKo0cjwARDI8AMRwOAI8A
EQzODD4QDiq9DA_PABhweh8ZDhAOiqUFIoo9kwDxAgpNHloMCgxNHmoMXR5afR46GSIAvwx1Kowd
HhoMCAIAlQ0eGg2MHR4KLSIAD64FJjQZHxcEAPcCbxkPIF8ZHxdfGQ8gDxkPIE8UAAAgABM-GAAE
BAD0Ay8ZHxcvGY8gHxkfFx8ZDyAIDgIAEQ8aACCOHe4FAdMhfw4tHN0c3fwNA_v1CpcOEA63DgAO
VwhXDgAORyhHHlcoRx5HSDcEAAAQABFnHgARtywAfiAOlw5AHlf0Ag9yACzwBycPEh5HSBcdHkdI
By0eVygHPR5nCAdFDyBnXS8Av20OEA43fQ4gHgeN4AIlgXcfEg4QDoctfgAhFz1-AJVNHlcoTR5H
SD0EAP8ANx0oTR4nPQhdHhe9HgfNxwInMBIfFwQAoG8SCF4fF14oTh0EADVOSD4EAAAQAFJuCF4d
3gIAH-2LAiAPMgD---8L-xEICAQgFlAXQA8cDxAfHCAOLxAeEB4NLhAXDScQXhBeAE0AHvIEHyBQ
BQ8VQAUuIAUOBy4QBSceEAkAAQUAH05RAB-yAhZABhAGYAYQFxAGIAcABxAHBgAQAAIATxcgB1BR
AB3-C0AoMDggBygPGBAnCA4QNwYQNwYgJwYwFwZAawE9HzYxAF1fEgTw-xEyABzwIDB-F2AOcQ5A
DpEOIA4RFQFFEQ4QDgEFDxYPIAUvFg8gDxYFAQ4QDgUdDyA9DB0FHQBQHQU9BR0VADARfRE1APAB
XREOMA4CcQIOIA4CHxVRG_oS4AIbHR8YCx0rAh4rLQotIQ--EBsVCBsVKw4gHnEeQA5xDlAOIR4h
DmAPEx8REBkPEzC3AHZACA8YW7YAMQgKW7YA0Ao7LQUOEB5xDQUOMA68AA_4ACov8ARwAWIPtABD
ECC2ACIfFggAArcAAA4AET8WAAG7AKENDyAFDB0MBQwNwAB-BQ0FHQUNBcYAYA59Aw8xAG4PrgMu
O7EOEAQAMCAOkVUBIX8VVgERnVMBjL0CHt0OAA69egNfLxMQLDB-AFYRnRECSB5xDAVGA08vExAr
jgIfDwQBLg4AAQ98AI4OjwIPMQCfB0ACMIEOMEkERAVBDiD9BHEPFgENIQ4g_gQwHQEFCwBAAR0F
HSIAMBE9QTAAkS0xDkAOAjEfFToEMBwRTGUBYBwdDxgdPHsVEE0IFsAcFQgVLA5AHmEOYA4EAKAh
DiEOcB8RDxMABQAfQJI8DA_wAEEgUQIGAFIfFTEcArAAUAgPGDwCsQAyLQgLswDPCxwtBQ4wHlEN
BQ5QtgAwL-AEZwFaD60ARAFVBg_uAAFRDQwFDA2wAE8FDQUNswAAMBsRS7MAEBuzABA7yBRATTsO
IEoGLxUrswAiDygDHg8xAI4PigNiAWwBEYAFAA_tAISwUA5hYA5BDgEPE2AiAp8PEVAbDxNQC0Bc
AYwCygI_IQ6wzQIPXAF6IQ5QZQBQIT4hDkCrAD8wHxHHCT8vMTAyAJEHeAEASggPeA1aAEELTh4h
DrBECw_2AIkgIR4uAm8OYAkfEYC2AB0v8AS3CS4gLxMzAS8sMHsAYI8hHi8TDmAsgMYCHw8yALEL
dAIPQgEFQZ8VDiCNIxHdPAEwnS8WbgwQHG8EIB4hwAGfER4rDmAuEC4wfwCcL-AEgAAgBbYCPxEe
LHcAmA5QAg8yAKMLNQJQER8WAU0pBRAtFgUQLQkAEgwIACwBnRkFkQ8VcQsOIA4rURcgACwMFmuM
EkAdCjs9WAIYHVgCHinhAQ_iALMv8ASjADQAWwYWO1oGRB0IGx1aBg_eAD5BHQ8gDbsqGB2iACIN
DBUAHw2qAF8PvgIPHzYxAI4PrgIpERNhAXAPFQsKUQsaCSAAsgKwKgsqHiotCAkKCzoiILkdCSoL
PQ4QDgthC7kCHidxAQ_sALwv8AStACw0HxULrACiHxgKHToeKi0JLakAvwgaHSoOIA4LcQsOogA-
AmgDMwANAGgDFgBoAwAbLg_uAFJQbT02fX0=
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTAzIDEzOjI2OjA5Iixtb2RpZmllZD0iMjAyNC0w
Ni0wNSAyMzoyMToyOSJdXWx6NAAEAAAAAwAAADBuaWw=
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTAzIDEzOjI2OjEwIixtb2RpZmllZD0iMjAyNC0w
Ni0wNSAyMzoyMToyOCIscmV2aXNpb249MjczNl1dbHo0ANkAAAB2EAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD-AF8xMDAwMgQAABM0CAAvMzCAAE4AYwATMggAojE5MDAyOTAwMGMQ
AA_AAFEAcABmMjgwMDE4jAAjMTiIAA_AAFAmMTl4ABMzdwEAfAAfMYAAUQBkAB9hBAAIL2IwAQD-
---------------E9Q0iKSxoaWRkZW49ZmFsc2UscGFuX3g9LTE5MS42AQARNxcAo3k9LTQxMy41
ODMBALI0LHRpbGVfaD0zMgoAEHcKAIB6b29tPTF9fQ==
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTAzIDEzOjI2OjA5Iixtb2RpZmllZD0iMjAyNC0w
Ni0wNSAyMzoyMToyOSJdXWx6NAAEAAAAAwAAADBuaWw=
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTAzIDEzOjI2OjEwIixtb2RpZmllZD0iMjAyNC0w
Ni0wNSAyMzoyMToyOCIscmV2aXNpb249MjU3Ml1dbHo0ACcBAADtFwAA-yxweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8AD--w-wEA6-8n0gEQBg8g
EAEgASAB8AACEAIMEAEgDyEgATAPQPDDDygP--DGD-gKD-8PgA-3Dw0B8AkBEAYMMAAcIg9AMQCD
D2-gAhACDz0zAE-wxw9CYgAdDzAA------9FH-8BAKz-XcgPQAACQB8TDxQPFQ8WDxcPGA8aDx0M
DyQPKQ8vDzMPOA88D0EPRQ9IH0oPRw9FD0EPPw89DzcPMg8vDywPKP--EfIP-hEPPQ8-X0BfPw8_
Dz1PPB87HzovOV84DzkeAf4K8HAPQAAPEED_sAoA--------------------fFD_sPD-OQ==
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTAzIDEzOjI2OjA5Iixtb2RpZmllZD0iMjAyNC0w
Ni0wNSAyMzoyMToyOSJdXWx6NAAEAAAAAwAAADBuaWw=
:: character.lua
--[[pod_format="raw",created="2024-05-05 22:21:00",modified="2024-06-05 23:21:28",revision=2804]]
include './types.lua'
include './collision.lua'

--object, start frame,
--num frames, speed, flip
function animate_character(o, sf, nf, sp, fl)
	if(not o.a_la) o.a_la = sf
	if(not o.a_ct) o.a_ct = 0
	if(not o.a_st) o.a_st = 0
	if(not o.fl) o.fl = false
	o.a_ct += 1
	if o.a_ct % (30/sp) == 0 then
	 o.a_st += 1
	 if(o.a_st == nf) o.a_st = 0
	elseif o.a_la != sf then
	o.a_st = 0
	end

	o.a_fr = sf + o.a_st
	spr(o.a_fr, o.x, o.y, fl)
	o.a_la = sf
end

character=entity:new({
	x=160,
   y=135,
   max_width = 16,
   max_height = 18,
   col_point = { x=0, y=0 },
   select_point = { x=0, y=0},
	i_dir = direction.up,
	spd=0.65,
	health = 10,
	wound_health = 51,
	pain = 40,
	hunger = 40,
	thirst = 31,
	delirium = 50,
	d_i_f = {sf = 196, nf = 4, s = 1, fl = false},
	u_i_f = {sf = 204, nf = 4, s = 1, fl = false},
	l_i_f = {sf = 212, nf = 4, s = 1, fl = false},
	r_i_f = {sf = 212, nf = 4, s = 1, fl = true},
	d_m_f = {sf = 228, nf = 2, s = 2, fl = false},
	u_m_f = {sf = 230, nf = 2, s = 2, fl = false},
	l_m_f = {sf = 220, nf = 4, s = 2, fl = false},
	r_m_f = {sf = 220, nf = 4, s = 2, fl = true},
	state = "idle",
	start_idle = nil,
	start_move = nil,
	update_vitals = function(self)
		if self.state == "idle" and self.health < 70 then
			last_update_move, current_update = 0, time_since(start_idle, time())
			if current_update != last_update_idle then
				last_update_idle = current_update
				self.health += 0.05
				self.hunger += 0.01
				self.thirst += 0.02
				if self.wound_health < 50 then
					self.wound_health += 0.01
				end
				if self.pain > 50 then
					self.pain -= 0.05
				end
			end
		end
		if self.state == "moving" then
			last_update_idle, current_update = 0, time_since(start_move, time())
			if current_update != last_update_move then
				last_update_move = current_update
				self.health -= 0.65
				self.wound_health -= 0.25
				self.pain += 0.1
				self.hunger += 0.1
				self.thirst += 0.1
			end
		end
		if self.health < 50 
			and self.wound_health < 50 
			and self.pain > 70 
			and self.hunger > 50 
			and self.thirst > 50 then
			last_update_idle, current_update = 0, time_since(start_move, time())
			if current_update != last_update_move then
				last_update_move = current_update
				self.delirium += 0.1
			end
		end
	end,
	move = function(self)
		_btn = btn()
		if _btn != button.none then
			self.state, self.start_move = "moving", time()
			self.col_point = { x = (self.x+(self.max_width/2)), y = (self.y+(self.max_height/2)) }
			if _btn == button.down_right then
				self.i_dir = direction.down
				self.col_point = { x = self.x+self.max_width, y = self.y+self.max_height}
				if collide(self,button.down_right) == false then
					self.y, self.x = self.y + (0.50 * self.spd), self.x + (1 * self.spd)
				end
			elseif _btn == button.up_left then
				self.i_dir = direction.up
				self.col_point = { x = self.x, y = self.y}
				if collide(self,button.up_left) == false then
					self.y, self.x = self.y - (0.50 * self.spd), self.x - (1 * self.spd)
				end
			elseif _btn == button.up_right then
				self.i_dir = direction.up
				self.col_point = { x = self.x+self.max_width, y = self.y }
				if collide(self,button.up_right) == false then
					self.y, self.x = self.y - (0.50 * self.spd), self.x + (1 * self.spd)
				end
			elseif _btn == button.down_left then
				self.i_dir = direction.down
				self.col_point = { x = self.x+1, y = self.y+self.max_height}
				if collide(self,button.down_left) == false then
					self.y, self.x = self.y + (0.50 * self.spd), self.x - (1 * self.spd)
				end
			elseif _btn == button.right then
				self.i_dir = direction.right
				self.col_point = { x = self.x+self.max_width, y = self.y+(self.max_height/2)}
				if collide(self,button.right) == false then
					self.x = self.x + (1 * self.spd)
				end
			elseif _btn == button.left then
				self.i_dir = direction.left
				self.col_point =  { x = self.x, y = self.y+(self.max_height/2)}
				if collide(self,button.left) == false then
					self.x = self.x - (1 * self.spd)
				end
			elseif _btn == button.down then
				self.i_dir = direction.down
				self.col_point = { x = self.x+(self.max_width/2), y = self.y+self.max_height}
				if collide(self,button.down) == false then
					self.y = self.y + (1 * self.spd)
				end
			elseif _btn == button.up then
				self.i_dir = direction.up
				self.col_point = { x = self.x+(self.max_width/2), y = self.y}
				if collide(self,button.up) == false then
					self.y = self.y - (1 * self.spd)
				end
			end
		else
			self.state = "idle"
			self.col_point = { x = (self.x+(self.max_width/2)), y = (self.y+(self.max_height/2)) }
			self.start_idle = time()
		end
		self.select_point = { x = (self.x+(self.max_width/2)), y = (self.y+(self.max_height/2)) }
	end,
	animate = function(self)
		if self.state == "idle" then
			if self.i_dir == direction.down then
				animate_character(
					self,
					self.d_i_f.sf,
					self.d_i_f.nf,
					self.d_i_f.s,
					self.d_i_f.fl
				)
			elseif self.i_dir == direction.up then
				animate_character(
					self,
					self.u_i_f.sf,
					self.u_i_f.nf,
					self.u_i_f.s,
					self.u_i_f.fl
				)
			elseif self.i_dir == direction.left then
				animate_character(
					self,
					self.l_i_f.sf,
					self.l_i_f.nf,
					self.l_i_f.s,
					self.l_i_f.fl
				)
			elseif self.i_dir == direction.right then
				animate_character(
					self,
					self.r_i_f.sf,
					self.r_i_f.nf,
					self.r_i_f.s,
					self.r_i_f.fl
				)
			end
		end
		if self.state == "moving" then
			if self.i_dir == direction.right then
					animate_character(
					self,
					self.r_m_f.sf,
					self.r_m_f.nf,
					self.r_m_f.s,
					self.r_m_f.fl
				)
			elseif self.i_dir == direction.left then
					animate_character(
					self,
					self.l_m_f.sf,
					self.l_m_f.nf,
					self.l_m_f.s,
					self.l_m_f.fl
				)
			elseif self.i_dir == direction.down then
					animate_character(
					self,
					self.d_m_f.sf,
					self.d_m_f.nf,
					self.d_m_f.s,
					self.d_m_f.fl
				)
			elseif self.i_dir == direction.up then
					animate_character(
					self,
					self.u_m_f.sf,
					self.u_m_f.nf,
					self.u_m_f.s,
					self.u_m_f.fl
				)
			end	
		end
	end,
	scan_area = function(self)
		local current_cel = { x = self.select_point.x/_tile_size, y = self.select_point.y/_tile_size}
		local tr_co = { x = current_cel.x + 1, y = current_cel.y - 1 }
		local tr_spr = mget(tr_co.x, tr_co.y)
		local tr_f = fget(tr_spr)
		local tl_co = { x = current_cel.x - 1, y = current_cel.y - 1 }
		local tl_spr = mget(tl_co.x, tl_co.y)
		local tl_f = fget(tl_spr)
		local t_co = { x = current_cel.x, y = current_cel.y - 1 }
		local t_spr = mget(t_co.x, t_co.y)
		local t_f = fget(t_spr)
		local r_co = { x = current_cel.x + 1, y = current_cel.y }
		local r_spr = mget(r_co.x, r_co.y)
		local r_f = fget(r_spr)
		local l_co = { x = current_cel.x - 1, y = current_cel.y }
		local l_spr = mget(l_co.x, l_co.y)
		local l_f = fget(l_spr)
		local br_co = { x = current_cel.x + 1, y = current_cel.y + 1 }
		local br_spr = mget(br_co.x, br_co.y)
		local br_f = fget(br_spr)
		local bl_co = { x = current_cel.x - 1, y = current_cel.y +1 }
		local bl_spr = mget(bl_co.x, bl_co.y)
		local bl_f = fget(bl_spr)
		local b_co = { x = current_cel.x, y = current_cel.y + 1 }
		local b_spr = mget(b_co.x, b_co.y)
		local b_f = fget(b_spr)
		local c_co = { x = current_cel.x, y = current_cel.y }
		local c_spr = mget(c_co.x, br_co.y)
		local c_f = fget(c_spr)
		
		if tr_f != 0 then
			add(_flagged_tiles,{ tile_co = tr_co, sprite = tr_spr, flags = tr_f })
		end
		if tl_f != 0 then
			add(_flagged_tiles,{ tile_co = tl_co, sprite = tl_spr, flags = tl_f })
		end
		if t_f != 0 then
			add(_flagged_tiles,{ tile_co = t_co, sprite = t_spr, flags = t_f })
		end
		if r_f != 0 then
			add(_flagged_tiles,{ tile_co = r_co, sprite = r_spr, flags = r_f })
		end
		if l_f != 0 then
			add(_flagged_tiles,{ tile_co = l_co, sprite = l_spr, flags = l_f })
		end
		if br_f != 0 then
			add(_flagged_tiles,{ tile_co = br_co, sprite = br_spr, flags = br_f })
		end
		if bl_f != 0 then
			add(_flagged_tiles,{ tile_co = bl_co, sprite = bl_spr, flags = bl_f })
		end
		if b_f != 0 then
			add(_flagged_tiles,{ tile_co = b_co, sprite = b_spr, flags = b_f })
		end
		if c_f != 0 then
			add(_flagged_tiles,{ tile_co = c_co, sprite = c_spr, flags = c_f })
		end
	end
})

:: collision.lua
--[[pod_format="raw",created="2024-05-17 20:59:47",modified="2024-06-05 23:21:28",revision=1688]]
include './types.lua'
include './util.lua'

function collide(o,d,r,f)
	r = r or 0
	f = f or 0		
	if fget2(mget((o.col_point.x/_tile_size) + r, (o.col_point.y/_tile_size)) + r,f) then
		return true
	end
	return false
end
:: inventory.lua
--[[pod_format="raw",created="2024-05-14 20:53:29",modified="2024-06-05 23:21:28",revision=2002]]
include './types.lua'
include './util.lua'
include './items.lua'

inventory_slot=entity:new({
	quantity = 0,
	item = nil
})

inventory=entity:new({
	max_width = 119,
	max_height = 68,
	max_capacity = 10,
	inv_starting_x = 0,
	cont_starting_x = 0,
	oo_ui = true,
	open = false,
	contents={},
	show = function(self)
		if 		 (_m_x) > _c_x-360
			and (_m_x) < (_c_x-121)
			and (_m_y) > _c_y
			and (_m_y) < (_c_y + 6)
		then
			self.oo_ui = false
			self.open = true
		else
			self.oo_ui = true
		end
		if self.open == true then
			spr(140,_c_x-360,_c_y)
			spr(140,(_c_x-240)+1,_c_y)
		else
			spr(132,_c_x-360,_c_y)
			spr(132,(_c_x-240)+1,_c_y)
		end	
		if not ((_m_y) < (_c_y+self.max_height)) and 
			((_m_l_b == true
			and self.oo_ui == true)
			or (_m_r_b == true 
			and self.oo_ui == true))
		then
			self.open = false
		end
	end,
	display_contents = function(self)
		local current_y = _c_y+10
		for i, c in pairs(self.contents) do
			spr(c.item.sprite,self.inv_starting_x,current_y)
			print(c.item.name,self.inv_starting_x+11, current_y)
			print(c.item.weight, self.inv_starting_x+80, current_y)
			current_y+=9
		end
	end,
	update = function(self)
		self.inv_starting_x = _c_x-358
		self.cont_starting_x = _c_x-238
		-- test contents
		self.show(self)
		if self.open then
			self.display_contents(self)
		end	
	end
})


:: items.lua
--[[pod_format="raw",created="2024-05-30 22:52:53",modified="2024-06-05 23:21:28",revision=774]]
item=entity:new({
	sprite = 0,
	name = "",
	amount = 100,
	weight = 1.0,
	item_type = nil
})

consumable=item:new({
	consume = function(self,o,a)
		self.amount -= a
		o.state = "consuming"
	end
})

water_bottle=consumable:new({
	sprite = 188,
	name = "Water Bottle",
	amount = 100,
	weight = 0.8,
	consume = function(self,o,a)
		consumable.consume(self,o,a)
		o.thirst -= a
	end
})

item_types = {
	consumable = 1,
	junk = 2,
	useable = 3,
	special = 4,
	unique = 5,
}
:: main.lua
--[[pod_format="raw",created="2024-05-03 13:26:10",modified="2024-06-05 23:21:28",revision=3055]]
include './util.lua'
include './character.lua'
include './moodles.lua'
include './inventory.lua'
include './static_interactable.lua'

_debug_message = ""

function _init()
	_w_w, _w_h = 480,270
	_tile_size = 32
	c=character:new({})
	m={moodles={}}
	_flagged_tiles = {}
   i_1 = water_bottle:new({})
	c_1 = inventory_slot:new({ quantity = 1, item = i_1})
	debug_inv = {}
	add(debug_inv,c_1)
	i=inventory:new({contents = debug_inv})
end

function _draw()
	_m_x, _m_y, _m_b, _m_w_x, _m_w_y = mouse()
	_c_x = c.x + (_w_w/2)
	_c_y = (c.y + (_w_h/2)) - 270
	_m_x = _m_x + (_c_x - _w_w)
	_m_y = _m_y + _c_y
	_m_l_b=_m_b&1>0
	_m_r_b=_m_b&2>0
	_m_m_b=_m_b&4>0
	cls(0)
	camera(c.x - (_w_w/2),c.y - (_w_h/2))
	map()
	i:update()
	c:animate()
	c:move()
	c:update_vitals()
	display_moodles(m,c)
	c:scan_area()
	temp_update_tiles()
	_flagged_tiles = {}
	debug()
end

function debug()
	print("debug_message: " .. _debug_message
			.. " c_x: " .. _c_x
			.. " c_y: " .. _c_y, _c_x-480, _c_y+260)
end
:: moodles.lua
--[[pod_format="raw",created="2024-05-07 21:40:35",modified="2024-06-05 23:21:28",revision=2346]]
include './types.lua'
include './util.lua'

moodle=entity:new({
	moodle = "none",
	sprite = 0,
	x = 0,
	y = 0,
})

function get_index(moodles, name)
	for i, m in ipairs(moodles) do
		if m.moodle == name then
			return i
		end
	end
	return -1
end

-- moodle entity, name, value, sprite 1, 2, 3, 4, lower check
function generate_moodle(m, n, v, s1, s2, s3, s4, lc)
	index = get_index(m.moodles, n)
	current_moodle = nil
	new_sprite = -1
	if index != -1 then
		current_moodle = m.moodles[index]
	end
	if lc then
		if v >= 20 and v < 30 then
			new_sprite = s1
		elseif v >= 30 and v < 50 then
			new_sprite = s2
		elseif v >= 50 and v < 70 then
			new_sprite = s3
		elseif v >= 70 then
			new_sprite = s4
		end
	else
		if v < 70 and v >= 50 then
			new_sprite = s1
		elseif v < 50 and v >= 30 then
			new_sprite = s2
		elseif v < 30 and v >= 10 then
			new_sprite = s3
		elseif v < 10 then
			new_sprite = s4
		end
	end
	if current_moodle == nil and new_sprite != nil then
		return moodle:new({moodle=n,sprite=new_sprite})
	elseif current_moodle != nil and current_moodle.sprite != new_sprite then
		del(m.moodles,current_moodle)
		return moodle:new({moodle=n,sprite=new_sprite})
	elseif current_moodle != nil and new_sprite == nil then
		del(m.moodles,current_moodle)
		return nil
	elseif current_moodle != nil and current_moodle.sprite == new_sprite then
		del(m.moodles,current_moodle)
		return moodle:new({moodle=n,sprite=new_sprite})
	end
	return nil
end

function display_moodles(m,c)
	m.moodles = {}
	h = generate_moodle(
		m, 
		"health", 
		c.health, 
		moodle_sprites.health_1, 
		moodle_sprites.health_2, 
		moodle_sprites.health_3, 
		moodle_sprites.health_4, 
		false)
	if h then
		add(m.moodles,h)
	end

	wh = generate_moodle(
		m, 
		"wound_health", 
		c.wound_health, 
		moodle_sprites.wound_health_1, 
		moodle_sprites.wound_health_2, 
		moodle_sprites.wound_health_3, 
		moodle_sprites.wound_health_4,
		false)
	if wh then
		add(m.moodles,wh)
	end

	p = generate_moodle(
		m, 
		"pain", 
		c.pain, 
		moodle_sprites.pain_1, 
		moodle_sprites.pain_2, 
		moodle_sprites.pain_3, 
		moodle_sprites.pain_4,
		true)
	if p then
		add(m.moodles,p)
	end

	hu = generate_moodle(
		m, 
		"hunger", 
		c.hunger, 
		moodle_sprites.hunger_1, 
		moodle_sprites.hunger_2, 
		moodle_sprites.hunger_3, 
		moodle_sprites.hunger_4,
		true)
	if hu then
		add(m.moodles,hu)
	end

	t = generate_moodle(
		m, 
		"thirst", 
		c.thirst, 
		moodle_sprites.thirst_1, 
		moodle_sprites.thirst_2, 
		moodle_sprites.thirst_3, 
		moodle_sprites.thirst_4,
		true)
	if t then
		add(m.moodles,t)
	end

	d = generate_moodle(
		m, 
		"delirium",
		c.delirium,
		moodle_sprites.delirium_1, 
		moodle_sprites.delirium_2, 
		moodle_sprites.delirium_3, 
		moodle_sprites.delirium_4,
		true)
	if d then
		add(m.moodles,d)
	end
	
	current_y = 1
	for i, moodle in pairs(m.moodles) do
		spr(moodle.sprite, _c_x-18, _c_y + current_y)
		current_y += 20
	end
end

moodle_sprites={
	health_1 = 168,
	health_2 = 169,
	health_3 = 170,
	health_4 = 171,
	wound_health_1 = 160,
	wound_health_2 = 161,
	wound_health_3 = 162,
	wound_health_4 = 163,
	pain_1 = 128,
	pain_2 = 129,
	pain_3 = 130,
	pain_4 = 131,
	delirium_1 = 136,
	delirium_2 = 137,
	delirium_3 = 138,
	delirium_4 = 139,
	hunger_1 = 152,
	hunger_2 = 153,
	hunger_3 = 154,
	hunger_4 = 155,
	thirst_1 = 144,
	thirst_2 = 145,
	thirst_3 = 146,
	thirst_4 = 147,
}
:: static_interactable.lua
--[[pod_format="raw",created="2024-05-23 20:57:56",modified="2024-06-05 23:21:28",revision=1452]]
include './types.lua'
include './collision.lua'
include './util.lua'

container=entity:new({
	max_capacity = 50,
})

draws=container:new({

})

function temp_update_tiles()
	for i,ft in pairs(_flagged_tiles) do
		if fget_precalc(ft.flags,1) == true then
			if ft.sprite == 4 then
				spr(5,(flr(ft.tile_co.x)*_tile_size), ((flr(ft.tile_co.y)*_tile_size)+16))
			end
		end
	end
end
:: types.lua
--[[pod_format="raw",created="2024-05-06 22:22:02",modified="2024-06-05 23:21:28",revision=2279]]
class={
	new=
		function(self,tbl)
			tbl=tbl or {}
			setmetatable(tbl, {
				__index=self
				}
			)
			return tbl
		end,
}

entity=class:new({
	x=0,
	y=0,
})

button={
	up=4,
	down=8,
	left=1,
	right=2,
	down_right=10,
	up_left=5,
	up_right=6,
	down_left=9,
	none=0
}

direction={
	up = 1,
	down = 2,
	left = 3,
	right = 4
}
:: until.lua
--[[pod_format="raw",created="2024-05-06 21:03:50",modified="2024-05-06 21:40:08",revision=95]]
function coalesce(a, b)
	if a == nil then
		return b
	else
		return a
	end
end

function time_since(start, current)
	return (flr(current) - flr(start))
end
:: util.lua
--[[pod_format="raw",created="2024-05-03 22:03:54",modified="2024-06-05 23:21:28",revision=2329]]
function coalesce(a, b)
	if a == nil then
		return b
	else
		return a
	end
end

function time_since(from, to)
	return flr(to) - flr(from)
end

function fget2(n, f)
	if f then
		return (fget(n)>>f)&1==1
	else
		return fget(n)
	end
end

function fget_precalc(pcf, f)
	return (pcf>>f)&1==1	
end

function tablelength(a)
  local count = 0
  for _ in pairs(a) do 
  	count = count + 1 
  end
  return count
end

:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTAzIDEzOjQ4OjQ3Iixtb2RpZmllZD0iMjAyNC0w
Ni0wNSAyMzoyMToyOSIscnVudGltZT03LHdvcmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEj
NDIiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImNoYXJhY3Rlci5sdWEjMzgiLHdvcmtz
cGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImNvbGxpc2lvbi5sdWEjMTEiLHdvcmtzcGFjZV9pbmRl
eD0xfSx7bG9jYXRpb249InN0YXRpY19pbnRlcmFjdGFibGUubHVhIzEzIix3b3Jrc3BhY2VfaW5k
ZXg9MX0se2xvY2F0aW9uPSJpbnZlbnRvcnkubHVhIzMzIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xv
Y2F0aW9uPSJpdGVtcy5sdWEjMTQiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249Im1vb2Rs
ZXMubHVhIzI4Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJ0eXBlcy5sdWEjMzQiLHdv
cmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InV0aWwubHVhIzI1Iix3b3Jrc3BhY2VfaW5kZXg9
MX0se2xvY2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7bG9jYXRpb249Im1h
cC8wLm1hcCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ic2Z4LzAuc2Z4Iix3b3Jrc3Bh
Y2VfaW5kZXg9NH19XV1sejQABAAAAAMAAAAwbmls
:: [eoc]
