picotron cartridge // www.picotron.net
version 2

:: gfx/
:: map/
:: sfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTAzIDEzOjI2OjEwIixtb2RpZmllZD0iMjAyNC0w
Ni0xNSAyMTowMzozNyIscmV2aXNpb249NDMzN11dbHo0AHQTAAB0WgAA8xR7WzBdPXtibXA9cHh1
AEMgEBAE8PAsZmxhZ3M9MCxwYW5feAgAz3k9MCx6b29tPTd9LDEABB8xMQB26fEg9iD-EQHRHlEW
Uf4CBwATAUsAHzJLABGEEhIE_gP2ABoDAP8CCgn-EQAZDtEOGQ5RFlEOGf4NAAhvCf8ZAvAUTAEZ
8QAICAT2AA8RUR4RFhEeVh4IAB6OQQAPKwETDzEABB82MQA3HzExAH8fMDEAEY8gIATw----8zQA
TQ_ZABAcOTEAov0EFh0WHRY9Fh0CAJ8G3QbtBv0ABu0JAAAfzVwAHTkAFh1eAC-9wEIAKx8NmgAF
AwkAHw1fABy-wCawNqBGoEagNgEDAA4OIgIPWwAKT-Yw8bAzABxAJsA2sI0ALwE2AwAPD44AH-MH
E4ZhhmGPEWGOYR5PEx43IY5hHk0eYQYAHzE5ARyT9jDxUEfxAAfhAgAfkUAAHBsNuQEPbgIyD-sC
HR-dfgAJD1ICJAUvAg8DABA-DaA2XwAdT-HQ-RAzABwFMwIPAwAOEQ0DAA9aAgwPcQQuOUEH4QIA
-wExJoEHIS8RkScuwS7xI-0QSgI7Gh2ABB8AXgAcPv3AFkIAD2UCNxkNXgAv-QRtAh4fDQMAGg-b
AU0CQQIPAwAPD2sCVQ8xAB5Q-Q4G-XibAS-9NzoAHZ8jBt0G-VcG-UU5AB1ADQb9STwAH2n9ASCP
RqBGsDbAJvBKAR1P-QD2MDUAHhMNKwdPsCbwrboBgm_GBs0G-SxqAB4PMQD--8wf8jEAHS--HMUA
Hg8xAP--------------1fQVQK8XIB6YDhAOuA4ADsgOAA4YDyAIDRgNCA0oHjgNOA04HigNEAAR
2AIAMTgNCAIAECgtAAUMAABBAL8gDpgOQB5YHnBeQIYAPDUoDxiIALMIHB6oLB6YPB6ITIwANQwN
LIwA-wUMDTwOAA5IfA4QDiiMDiAenA5Aro0AIdNoLxgOEA54PQ4ADnhNkQDxBAwYDA0MLR44DBgd
DD0eKAwIDB0RANFIjR44nR4orR4YHQANAgA0LR4ICwAwPR7dAgAv-gGGABx0-xcB3xgfFwQAky8Y
DyAPGA8gHwgAgi8YHxc-GA8gBAAPIAADF98EABM-GAAXDyAABDQABAQAFz8wAE-fGP8XswAatHcG
BP8XaP8gZR8XBQC8DxcADv8gYw4g-mP3FfMALTQuMDU5NTIzODA5NTI0WQCiLTguNzE5MDQ3NgYA
AmgAGTJoANF0EgQQ-xRgIP5iAP7-AQB-TgD_YiD_YFoWDB8yKwMdLzEwMgAvAUsC8QufHg4QDr0O
AA7NDgAOHQddBy0eHSc9Jx0eLQwAAB8C-hENvyANHg0MlwwNDgAODQx3DA0OEA4dfB0OIA6dDkAe
XVMDD3wAMYAdAh69Eh6tIn8AEQJ-ABMCfwAQEi4AznwiDhAOPXIOIB4NgkYDD4AAEyBvHkUAcX0y
DgAOfUKDAPcJPRIHIh4dJx0SJxIeLQcdMgciHk2CHj2ShQAgHh2DAL8eDRJ8Ih7SHtL_AXsAHUD-
FwHSOgDDHiIHUgciHhInMicSDAAAFgAQAmoA7wINlw0CHhINdw0SHiJ9aQAhIHdE8gJwjyAPF-8g
NgUAEAIFABAB_wL1AEUfF08gHxe-ID8XbyAfFyQAIj8gGQAxTyAPBAAxHyAfIQAFMgAXrxUACTYA
Ex8ZAAA2ADFfID8QABQ-OgAzDyAPBABCHxffIBAAGk9CAFEvFy8gLz4AY38gLxdfIKYDDb4ANP8X
ab8DDwUA9g-IBAhGNy41MwEAAy8CZC0xLjMxNgEAHzfGBAYfE8YEEE81NC4zYgAAGTAWAC8zNC8g
JA-kBDbyC5wOEA68DgAOPD8gTA4ADiwNPA08HjxdPB48CgAIBgABFgAhPxCpB-4ELA07DSwOEA48
PTwOIA6cDkAeXOwED4QAMTEsDxAIACEcGwcAwwwrHjxdOx48DTsNO4cAAAgAzzw9Sw4QDiyLDiAe
m-MEJYJ8HxAOEA6MLYoAEAxCCLIsCzwLPR48Wz0ePAoABwYA4SwNWz0eHB0LPQs9HgwtBwA_TTtN
MwgP_AQUQN8QHxcEAPEATxA-IE8QHxc-EA8gPA4-CgCpXj0fFz0OPA49GwYAEF4KACQ9DgYAj00_
TRvdG937fgAeL-DwMgCzAcYB9wWbDhAOuw4ADksvIEsOAA5bDVseawQA-hxbDQkNSx5LDSkNOx47
DUkNKw4ADisNSQ0bDhAOOw0pDSsOIA47LSsOQB5b0AIPgwAtcUsDHmsNOxOFACEbI4YAETOGABMj
hgAACAAAhgDPMw4QDisDLUMOIB6TzwIlcnsTDhAOiyOIACELM4kAYQtDHmsNUwQA4VsDDVMeSwMN
CQ1DHjsDigAgKwODADEeGxMHACELMxUAX1MtQx7T0gIiydMe0x5TLyBDHmMNUwQAEVN1ABFDXwAR
M2wAAgYAH0NxACkv8PAyALMBvAHxEZoOEA66DgAOyg4ADloPIFoeWg0KDUoeag1aHtoeOg0KAgCV
Kh4qjRoeGg0IAgCzCg4ADhqNCg4QDiokAJ4aDiAOmg5AHlrNAg_LACm1Og8ZHmoNOhweqiyPAFks
HiqNHI8AEQyPADEcDgCPABEM7w0_EA4q3g0PjwAYcHofGQ4QDoqlBSKKPZMA8QQKTR5aDAoMTR5q
DF0eWn0eOgwNAgCVLR4qjB0eGgwIAgCVDR4aDYwdHgotIgAPrgUmNBkfFwQA9wJvGQ8gXxkfF18Z
DyAPGQ8gTxQAACAAEz8YAAQEAPQDLxkfFy8ZjyAfGR8XHxkPIAgOAgARDxoAII4d7gURDQIAby0c
3Rzd-A0D6-UKlw4QDrcOAA5XCFcOAA5HKEceVyhHHkdINwQAABAAEWceABG3LAB_IA6XDkAeV-QC
D3IALPAHJw8SHkdIFx0eR0gHLR5XKAc9HmcIB2YQIGddLwC-bQ4QDjd9DiAeB43gAiWBdx8SDhAO
hy1_ACEXPX8AlU0eVyhNHkdIPQQA-wA3HShNHic9CF0eF70eB83HAicwEh8XBACgbxIIXh8XXihO
HQQANU5IPgQAABAAUm4IXh3eAgAf-YsCIA8yAP---wv-EQgIBCAWUBdADxwPEB8cIA4vEB4QHg0u
EBcNJxBeEF4ATQAe8gQfIFAFDxVABS4gBQ4HLhAFJx4QCQABBQAfTlEAH-ICFkAGEAZgBhAXEAYg
BwAHEAcGABAAAgBPFyAHUFEAHf8LQCgwOCAHKA8YECcIDhA3BhA3BiAnBjAXBkBrAT0fNjEAXV8S
BPD-ETIAHPAgMH8XYA5xDkAOkQ4gDhEVAUURDhAOAQUPFg8gBS8WDyAPFgUBDhAOBR0PID0MHQUd
AFAdBT0FHRUAMBF9ETUA8AFdEQ4wDgJxAg4gDgIfFVEbCxTgAhsdHxgLHSsCHistCi0hD-8QGxUI
GxUrDiAecR5ADnEOUA4hHiEOYA8THxEQGQ8TMLcAdkAIDxhbtgAxCApbtgDQCjstBQ4QHnENBQ4w
DrwAD7gAKi-wBHABYg_0AEMQILYAIh8WCAACtwAADgARPxYAAbsAoQ0PIAUMHQwFDA3AAH8FDQUd
BQ0FxgBgDn0DDzEAbg_uAy47sQ4QBAAwIA6RVQEhfxVWARGdUwGMvQIe3Q4ADr16A18vExAsMH8A
VhGdEQJIHnEMBUYDTy8TECuOAh8PBAEuDgABD3wAjg6PAg8xAJ7wCBEiBPAITxOgDh8bIw6ADh0D
Dh8VAw5gCQBADw4PFQQAMQMOUA8AFBcRAAIQAH0fFwcPIA8ODQByEw4PFx8NAwsAEjMHACEjHlIA
YAMuYA4NDi4AEA1jADEjDgwnAPIFQw4DDQ4wDh1jDgMOMA4NEw0uLxgKAPsVPQ4dCw5AHjMNDhMI
DlAuIw4TCw5gTgsYHmAODRNeYA4NUw0OBgBgAw4zDQ5wUgDQAAMdDnA_ABMNDnABLgcAQGAhHgAZ
AP8LUBELERAxQBELAQsgAStQCyEgCyELUCEgQRBMORkAOgEfGToBeiEdAzoBYA0OIA4dAzsBwQ0O
MB4jHQ4TCA0OQD0B4A0OUE4LGC5gDhMNEy5wBgBiDQ6ADhMOBwD-Ig0OAx6QDhMNLoAuDQMNDoAB
PgMNDnAhLgMNDmBBAD5QASsBEDFgIQsQATtgMQALMTAvAQwPaQKfLyMdaQIB0W5QDg1jDQ5QDg0j
DiMIACATHjoBAZEAMAAOE3QAQA4ATmBeALAADgEecA4TDgAhDgcA-wURCxFwQQsBC4ABOyGACyEA
IYBBYDYBGQnfBDCBDjDpB0UFQQ4g6QdxDxYBDSEOIJsIMB0BBQsAYAENDAUMDSUAANsHIA1BNgCR
LTEOQA4CMR8V4AcwGxFLCwVgGx0PGB07VBZATTsOINYHEBXiFuBhDmAOIQ4hDnAfEQ8TAAUAH0Cz
AAwPtAQeDzEAjQ_tAnwA0gMCrgJDEw0OEK8CABYAAhoFACgAAbMCswMNDkBOCxgODR5AtwIPIAVa
HzYgBYkCFgUFRAElHQNEAS8jHUQBAxBQIAUvPmAmBS4PeQKfHxN4Ag4PNAEFH0AvBV0P6QMeHzQx
AL7wBhUiBPANTxPgDkMOwA4DTxUDDqAOAxkCFR8yAjGQDg8xAhYfNQIwkA4PJQJ6LxcPIAcPDg8A
kRcOkA4NHw0NDwYA8B4OkA5zDxsOkB5DHB6ADhweEwweHA5gDjwOLQ48DkAOHDMODQ4zHA4gDhxT
DlPXGRAcaQLxEmMcHhwDHB5PGEMcHhwTLA4sGwMOExwOAB4MExwOEwwLCA8AEBBAAjEMCAsNAPgP
MD4LGA8ZCy4TDB5ADgweCwoIHgxOUA4MYwwOABwDCQAAZwDlHGAeEy4MAwwOkE4ADhMHACKgMQcA
-wwBGwEADiwOoDsAMbA7ABErsBsQAQshC-AAQTBdAR0fIl0Bby8QHl0BBS8OAF4BSBITVgGRHpBO
AE6gMQBOVgH-A0GgCxELAAE7oDEAS7ARIAshQK4C-wwRHKUBUmAODAMMsAKCDgwTDgAeAx4JABJO
BwD-DTGgDiwOAAEbAbAxADugKxEAO5ALIQsBEBugQbCxAv8kYJBOADGgQVMBwKA7AQALEQugSwAx
oFQBLxFgwgUeDzEArAV2A-EBTxsOwA4dIx0OoA4NUx0OkKsHDwYABuEeDUMNHqAuIy6QHh1DHbkH
cA1DDQ4dDkBHCFANIw0OE9QqcA0jHVMNEx1tKhEzXQCwIx0eHRMOAx4jHgMDCDEAHh1QAIAjDQ4Q
Ph1DHQkAcDAuHSMdHhNLAAIoABATPgjig05QDoMOAA0TUA4zDjMJADEDDQNqCeAADQNgTgAOAx0O
kAEuAaoK8AYDDpBBAA4jDpABLxgBAAEjAZBMAEEEAK_gLBAMIQzwASxQPggZTxUiBHAkASlfLg1D
DS4kAVoJKwFQA2AeAz4pAR_QJgEEEUEjAWBBAEGgIRAyAT-wAEwjAQ8fM0gCtiAjLgwBACgBAB4B
AHgFARAA4AEuAZAOIw4AQZABIwEAGAFBkEEATAQAjwwhDBAssCywIgEMD0UCu1AODQMNPp0GDyUB
BxBBRQIBdQMwECGgRAIPIgEND_4EHg8xAI2BEyIE8ApPE8CoDRSgqA0agKgNMHAODX4NBWUHARAA
BJsNDA0AEyOoDRBw8QESMwcAUCMegB4NqA1ggA4dDgMuuA9BHTMeA0sNMVMOE9sOM3MOE6cNQj4v
GCOnDUBNDh0MFgBgHkMNDhMIKABALjMOExMAYEBeDBgOAwECqQ0jflAODXMODQMHAADwEhANJAJA
DnAOLa8NEA3XACANE7kNDwkAAeBBADGAESwAESxwAQwhDAQAPXBBACkQVy0wLjE2AQATN1wBRzEu
ODMBAA6VBQ9qAUsmDSNqAdBwLhMOAy5wDi0OAy4dYQFCQx4DHQgPEyM8EBBThQMAOxAAawEAkAMQ
HhEPEAwnABAuogOjCAMdDkBOAw4TDGIBng4MGD5QDg0zTmUBP3MOcGoBfQ4FAw9PAHnxABEZBPAG
bxOADmMOYA4DbwcRMQ8WB_scEBWnCgAIESAPH7YKEB8PABAfeRBgHxYNDA0cMAPxHnMPEQ5QHlML
HlA_LT5ADgsPGxMODA4TCgsOMA4KIy4jCg4gDgtDDkMLDhAOAwwF8AEDDhAuMw4zLhADCguOCwoD
CAASgwgAwQAOYw4ACgNADgMLAwQAUXAOCwMLBACxcA4jDiMOcDEAMXCUCIEpYDEJAAkxUAYAHyBj
BAUP8QBNEFDxAOADDgwOAwoLDkAOCwoTLvsAYCAOCkMOQxkqDfsAF_7vAEQLDmMO_QAE8gAB-wAP
9QA-DjUCDzEAPQ_ADvUvDhMKAAUhLA45ETAxADGHDjARK4CIDhAAPRE9cEEgPhFXLTcuNzIBAAR8
AT4uMjb7Nx81iwFmMJAODIsB4AwOgA4sDi0OLA5gDhwjiwEQDJUBMUMOQ5MBAP8CA5UBHAyNASce
Q4oBNgAeQ4oBQyAeEw6MAUAcDkA_igERM5UBPWMMTogBJQNQiQEBlQEPiwFmD9gLtjUNAw0gDgAX
CAL9DAK4CgEGAAG6CgEnDiQjAQMNAQQA3w8YIQwADCEMoCwgLFBNAXNPgE4jTv4LbQFOAR_QSwFi
UG09NX19
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTAzIDEzOjI2OjA5Iixtb2RpZmllZD0iMjAyNC0w
Ni0xNSAyMTowMzozNyJdXWx6NAAEAAAAAwAAADBuaWw=
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTAzIDEzOjI2OjEwIixtb2RpZmllZD0iMjAyNC0w
Ni0xNSAyMTowMzozNyIscmV2aXNpb249NDAxMF1dbHo0AO4AAAB2EAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD_YzEzMDAxNAQAVzYwMDE3EAAABAAvNTABAEpQMWIwMDBoABNjBAAX
ZgwAAAQAL2QwAQBKEDIAAQCIAB8xBAAAXzIwMDI1gABQXzgwMDE5BAAAH2GAAF8vMmGAAGsvMTmA
AOMXMngAHzIAAdlfYjAwMmMEAAgvZDABAP------------9C9Q0iKSxoaWRkZW49ZmFsc2UscGFu
X3g9LTEzOC4zAQARNBcAdnk9LTE2OC4AC7IxLHRpbGVfaD0xNgoAEHcKAIB6b29tPTJ9fQ==
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTAzIDEzOjI2OjA5Iixtb2RpZmllZD0iMjAyNC0w
Ni0xNSAyMTowMzozNyJdXWx6NAAEAAAAAwAAADBuaWw=
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTAzIDEzOjI2OjEwIixtb2RpZmllZD0iMjAyNC0w
Ni0xNSAyMTowMzozNyIscmV2aXNpb249Mzc5Nl1dbHo0ACcBAADtFwAA-yxweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8AD--w-wEA6-8n0gEQBg8g
EAEgASAB8AACEAIMEAEgDyEgATAPQPDDDygP--DGD-gKD-8PgA-3Dw0B8AkBEAYMMAAcIg9AMQCD
D2-gAhACDz0zAE-wxw9CYgAdDzAA------9FH-8BAKz-XcgPQAACQB8TDxQPFQ8WDxcPGA8aDx0M
DyQPKQ8vDzMPOA88D0EPRQ9IH0oPRw9FD0EPPw89DzcPMg8vDywPKP--EfIP-hEPPQ8-X0BfPw8_
Dz1PPB87HzovOV84DzkeAf4K8HAPQAAPEED_sAoA--------------------fFD_sPD-OQ==
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTAzIDEzOjI2OjA5Iixtb2RpZmllZD0iMjAyNC0w
Ni0xNSAyMTowMzozNyJdXWx6NAAEAAAAAwAAADBuaWw=
:: character.lua
--[[pod_format="raw",created="2024-05-05 22:21:00",modified="2024-06-15 21:03:37",revision=4187]]
include './types.lua'
include './util.lua'

character=entity:new({
	x=160,
   y=135,
   max_width = 21,
   max_height = 34,
   col_point = { x=0, y=0 },
   select_point = { x=0, y=0},
	i_dir = direction.up,
	spd=0.35,
	health = 90,
	wound_health = 90,
	pain = 10,
	hunger = 10,
	thirst = 50,
	delirium = 0,
	d_i_f = {sf = 252, nf = 2, s = 0.5, fl = false},
	u_i_f = {sf = 254, nf = 2, s = 0.5, fl = false},
	l_i_f = {sf = 244, nf = 2, s = 0.5, fl = true},
	r_i_f = {sf = 244, nf = 2, s = 0.5, fl = false},
	d_m_f = {sf = 228, nf = 4, s = 4, fl = false},
	u_m_f = {sf = 236, nf = 4, s = 4, fl = false},
	l_m_f = {sf = 212, nf = 3, s = 4, fl = true},
	r_m_f = {sf = 212, nf = 3, s = 4, fl = false},
	state = "idle",
	start_idle = nil,
	start_move = nil,
})

function move_character(c)
	_btn = btn()
	_w, _a, _s, _d = key("w"), key("a"), key("s"), key("d")
	_none = true
	if (_w or _a or _s or _d) _none = false 
	if _btn != button.none or not _none then
		c.state, c.start_move = "moving", time()
		c.col_point = { x = (c.x+(c.max_width/2)), y = (c.y+(c.max_height/2)) }
		if _btn == button.down_right or (_s and _d) then
			c.i_dir = direction.down
			c.col_point = { x = c.x+c.max_width, y = c.y+c.max_height}
			if collide(c) == false then
				c.y, c.x = c.y + (0.50 * c.spd), c.x + (1 * c.spd)
			end
		elseif _btn == button.up_left or (_w and _a) then
			c.i_dir = direction.up
			c.col_point = { x = c.x, y = c.y}
			if collide(c) == false then
				c.y, c.x = c.y - (0.50 * c.spd), c.x - (1 * c.spd)
			end
		elseif _btn == button.up_right or (_w and _d) then
			c.i_dir = direction.up
			c.col_point = { x = c.x+c.max_width, y = c.y }
			if collide(c) == false then
				c.y, c.x = c.y - (0.50 * c.spd), c.x + (1 * c.spd)
			end
		elseif _btn == button.down_left or (_s and _a) then
			c.i_dir = direction.down
			c.col_point = { x = c.x+1, y = c.y+c.max_height}
			if collide(c) == false then
				c.y, c.x = c.y + (0.50 * c.spd), c.x - (1 * c.spd)
			end
		elseif _btn == button.right or _d then
			c.i_dir = direction.right
			c.col_point = { x = c.x+c.max_width, y = c.y+(c.max_height/2)}
			if collide(c) == false then
				c.x = c.x + (1 * c.spd)
			end
		elseif _btn == button.left or _a then
			c.i_dir = direction.left
			c.col_point =  { x = c.x, y = c.y+(c.max_height/2)}
			if collide(c) == false then
				c.x = c.x - (1 * c.spd)
			end
		elseif _btn == button.down or _s then
			c.i_dir = direction.down
			c.col_point = { x = c.x+(c.max_width/2), y = c.y+c.max_height}
			if collide(c) == false then
				c.y = c.y + (1 * c.spd)
			end
		elseif _btn == button.up or _w then
			c.i_dir = direction.up
			c.col_point = { x = c.x+(c.max_width/2), y = c.y}
			if collide(c) == false then
				c.y = c.y - (1 * c.spd)
			end
		end
	else
		c.state = "idle"
		c.col_point = { x = (c.x+(c.max_width/2)), y = (c.y+(c.max_height/2)) }
		c.start_idle = time()
	end
	c.select_point = { x = (c.x+(c.max_width/2)), y = (c.y+(c.max_height/2)) }
end

function animate_character(c)
	if c.state == "idle" then
		if c.i_dir == direction.down then
			animate_sprite(
				c,
				c.d_i_f.sf,
				c.d_i_f.nf,
				c.d_i_f.s,
				c.d_i_f.fl
			)
		elseif c.i_dir == direction.up then
			animate_sprite(
				c,
				c.u_i_f.sf,
				c.u_i_f.nf,
				c.u_i_f.s,
				c.u_i_f.fl
			)
		elseif c.i_dir == direction.left then
			animate_sprite(
				c,
				c.l_i_f.sf,
				c.l_i_f.nf,
				c.l_i_f.s,
				c.l_i_f.fl
			)
		elseif c.i_dir == direction.right then
			animate_sprite(
				c,
				c.r_i_f.sf,
				c.r_i_f.nf,
				c.r_i_f.s,
				c.r_i_f.fl
			)
		end
	end
	if c.state == "moving" then
		if c.i_dir == direction.right then
			animate_sprite(
				c,
				c.r_m_f.sf,
				c.r_m_f.nf,
				c.r_m_f.s,
				c.r_m_f.fl
			)
		elseif c.i_dir == direction.left then
			animate_sprite(
				c,
				c.l_m_f.sf,
				c.l_m_f.nf,
				c.l_m_f.s,
				c.l_m_f.fl
			)
		elseif c.i_dir == direction.down then
			animate_sprite(
				c,
				c.d_m_f.sf,
				c.d_m_f.nf,
				c.d_m_f.s,
				c.d_m_f.fl
			)
		elseif c.i_dir == direction.up then
			animate_sprite(
				c,
				c.u_m_f.sf,
				c.u_m_f.nf,
				c.u_m_f.s,
				c.u_m_f.fl
			)
		end	
	end
end

function scan_character_area(c)
	local current_cel = { x = flr(c.select_point.x/_tile_size), y = flr(c.select_point.y/_tile_size) }
	local tr_co = { x = current_cel.x + 1, y = current_cel.y - 1 }
	local tr_spr = mget(tr_co.x, tr_co.y)
	local tr_f = fget(tr_spr)
	local tl_co = { x = current_cel.x - 1, y = current_cel.y - 1 }
	local tl_spr = mget(tl_co.x, tl_co.y)
	local tl_f = fget(tl_spr)
	local t_co = { x = current_cel.x, y = current_cel.y - 1 }
	local t_spr = mget(t_co.x, t_co.y)
	local t_f = fget(t_spr)
	local r_co = { x = current_cel.x + 1, y = current_cel.y }
	local r_spr = mget(r_co.x, r_co.y)
	local r_f = fget(r_spr)
	local l_co = { x = current_cel.x - 1, y = current_cel.y }
	local l_spr = mget(l_co.x, l_co.y)
	local l_f = fget(l_spr)
	local br_co = { x = current_cel.x + 1, y = current_cel.y + 1 }
	local br_spr = mget(br_co.x, br_co.y)
	local br_f = fget(br_spr)
	local bl_co = { x = current_cel.x - 1, y = current_cel.y +1 }
	local bl_spr = mget(bl_co.x, bl_co.y)
	local bl_f = fget(bl_spr)
	local b_co = { x = current_cel.x, y = current_cel.y + 1 }
	local b_spr = mget(b_co.x, b_co.y)
	local b_f = fget(b_spr)
	local c_co = { x = current_cel.x, y = current_cel.y }
	local c_spr = mget(c_co.x, br_co.y)
	local c_f = fget(c_spr)
	
	if tr_f != 0 then
		add(_flagged_tiles,{ tile_co = tr_co, sprite = tr_spr, flags = tr_f })
	end
	if tl_f != 0 then
		add(_flagged_tiles,{ tile_co = tl_co, sprite = tl_spr, flags = tl_f })
	end
	if t_f != 0 then
		add(_flagged_tiles,{ tile_co = t_co, sprite = t_spr, flags = t_f })
	end
	if r_f != 0 then
		add(_flagged_tiles,{ tile_co = r_co, sprite = r_spr, flags = r_f })
	end
	if l_f != 0 then
		add(_flagged_tiles,{ tile_co = l_co, sprite = l_spr, flags = l_f })
	end
	if br_f != 0 then
		add(_flagged_tiles,{ tile_co = br_co, sprite = br_spr, flags = br_f })
	end
	if bl_f != 0 then
		add(_flagged_tiles,{ tile_co = bl_co, sprite = bl_spr, flags = bl_f })
	end
	if b_f != 0 then
		add(_flagged_tiles,{ tile_co = b_co, sprite = b_spr, flags = b_f })
	end
	if c_f != 0 then
		add(_flagged_tiles,{ tile_co = c_co, sprite = c_spr, flags = c_f })
	end
end

function update_character_vitals(c)
	if c.state == "idle" and c.health < 70 then
		last_update_move, current_update = 0, time_since(start_idle, time())
		if current_update != last_update_idle then
			last_update_idle = current_update
			c.health += 0.05
			c.hunger += 0.01
			c.thirst += 0.02
			if c.wound_health < 50 then
				c.wound_health += 0.01
			end
			if c.pain > 50 then
				c.pain -= 0.05
			end
		end
	end
	if c.state == "moving" then
		last_update_idle, current_update = 0, time_since(start_move, time())
		if current_update != last_update_move then
			last_update_move = current_update
			c.health -= 0.65
			c.wound_health -= 0.25
			c.pain += 0.1
			c.hunger += 0.1
			c.thirst += 0.1
		end
	end
	if c.health < 50 
		and c.wound_health < 50 
		and c.pain > 70 
		and c.hunger > 50 
		and c.thirst > 50 then
		last_update_idle, current_update = 0, time_since(start_move, time())
		if current_update != last_update_move then
			last_update_move = current_update
			c.delirium += 0.1
		end
	end
end

:: inventory.lua
--[[pod_format="raw",created="2024-05-14 20:53:29",modified="2024-06-15 21:03:37",revision=3537]]
include './types.lua'
include './util.lua'
include './items.lua'

inventory=entity:new({
	max_width = 119,
	max_height = 68,
	max_capacity = 10,
	inv_starting_x = 0,
	cont_starting_x = 0,
	oo_ui = true,
	open = false,
	total_weight = 0,
	capacity = 10,
	selected_container = 1,
	contents={},
})

function add_to_inventory(c_i,item)
	existing_item = nil
	for i, s in pairs(c_i.contents) do
		if s.item.sprite == item.sprite then
			existing_item = s
			del(c_i.contents, s)
		end
	end
	if existing_item then
		existing_item.quantity += 1
		add(c_i.contents, existing_item)
	else
		slot = container_slot:new({quantity = 1, item = item})
		add(c_i.contents, slot)
	end
end

function display_inventory_contents(c_i)
	local current_y = flr(_c_y+13)
	print("Inventory", c_i.inv_starting_x+11, current_y-11, 23)
	c_i.total_weight = 0
	for i, c in ipairs(c_i.contents) do
		c.starting_x = c_i.inv_starting_x
		c.starting_y = current_y
		c.ending_x = c_i.inv_starting_x+114
		c.ending_y = current_y+8
		if (_m_x) > c.starting_x
			and (_m_x) < c.ending_x
			and (_m_y) > c.starting_y
			and (_m_y) < c.ending_y then
			rect(c.starting_x-1, c.starting_y-2, c.ending_x+1, c.ending_y+1, 2)
		end
		spr(c.item.sprite,c_i.inv_starting_x,current_y, 23)
		print(c.item.name,c_i.inv_starting_x+11, current_y, 23)
		print(c.item.weight, c_i.inv_starting_x+80, current_y, 23)
		print(c.quantity, c_i.inv_starting_x+103, current_y, 23)
		current_y+=10
		c_i.total_weight += (c.item.weight*c.quantity)
	end
end

function display_container_contents(c_i)
	local current_y = flr(_c_y+13)
	print("Container(s)", c_i.cont_starting_x+11, current_y-11, 23)
	local cont_icn_x = c_i.cont_starting_x+2
	local cont_icn_y = current_y+45
	for i, cc in ipairs(_containers) do
		if cc.in_range == false then return end

		local cont_icn_b_s_x = cont_icn_x - 1
		local cont_icn_b_s_y = cont_icn_y - 1
		local cont_icn_b_e_x = cont_icn_x + 8
		local cont_icn_b_e_y = cont_icn_y + 8
		if i == c_i.selected_container then
			rect(cont_icn_b_s_x, cont_icn_b_s_y, cont_icn_b_e_x, cont_icn_b_e_y, 2)
			spr(cc.small_icon, cont_icn_x, cont_icn_y)
			for j, ccc in ipairs(cc.contents) do
				local m_is_on = false
				ccc.starting_x = c_i.cont_starting_x
				ccc.starting_y = current_y
				ccc.ending_x = c_i.cont_starting_x+114
				ccc.ending_y = current_y+8
				if (_m_x) > ccc.starting_x
				and (_m_x) < ccc.ending_x
				and (_m_y) > ccc.starting_y
				and (_m_y) < ccc.ending_y then
					rect(ccc.starting_x-1, ccc.starting_y-2, ccc.ending_x+1, ccc.ending_y+1, 2)
					m_is_on = true
				end
				spr(ccc.item.sprite, c_i.cont_starting_x,current_y)
				print(ccc.item.name, c_i.cont_starting_x+11, current_y, 23)
				print(ccc.item.weight, c_i.cont_starting_x+80, current_y, 23)
				print(ccc.quantity, c_i.cont_starting_x+100, current_y, 23)
				current_y+=10
			end
		else
			rect(cont_icn_b_s_x, cont_icn_b_s_y, cont_icn_b_e_x, cont_icn_b_e_y, 21)
			spr(cc.small_icon, cont_icn_x, cont_icn_y)
			if _m_l_b and ((_m_x) > cont_icn_b_s_x
			and (_m_x) < cont_icn_b_e_x
			and (_m_y) > cont_icn_b_s_y
			and (_m_y) < cont_icn_b_e_y) then
				c_i.selected_container = i	
			end
		end
		cont_icn_x+=10
	end
end

function show_inventory(c_i)
	if      (_m_x) > _c_x-360
		and (_m_x) < (_c_x-121)
		and (_m_y) > _c_y
		and (_m_y) < (_c_y + 6)
	then
		c_i.oo_ui = false
		c_i.open = true
	else
		c_i.oo_ui = true
	end
	if c_i.open == true then
		spr(140,_c_x-360,_c_y)
		spr(140,(_c_x-240)+1,_c_y)
	else
		spr(132,_c_x-360,_c_y)
		spr(132,(_c_x-240)+1,_c_y)
	end	
	if not ((_m_y) < (_c_y+c_i.max_height)) and 
		((_m_l_b == true
		and c_i.oo_ui == true)
		or (_m_r_b == true 
		and c_i.oo_ui == true))
	then
		c_i.open = false
	end
end

function display_inventory_weight(c_i)
	local s_x = c_i.inv_starting_x-1
	local s_y = _c_y+1
	local p_c = (c_i.total_weight / c_i.capacity) * 100
	local p_r = (7.3/100)*p_c
	local e_x = s_x + p_r
	local e_y = s_y + p_r
	rectfill(s_x, s_y, e_x, e_y, 1)
end

function update_inventory(c_i)
	c_i.inv_starting_x = flr(_c_x-358)
	c_i.cont_starting_x = flr(_c_x-237)
	-- test contents
	show_inventory(c_i)
	if c_i.open then
		display_inventory_contents(c_i)
		display_inventory_weight(c_i)
		if table_length(_containers) > 0 then
			display_container_contents(c_i)
		else
			_debug_message = "enters dealocate selected container"
			c_i.selected_container = 1
		end
	end	
end

:: items.lua
--[[pod_format="raw",created="2024-05-30 22:52:53",modified="2024-06-15 21:03:37",revision=2074]]
item=entity:new({
	sprite = 0,
	name = "",
	amount = 100,
	weight = 1.0,
	item_type = nil
})

consumable=item:new({
	consume = function(self,o,a)
		self.amount -= a
		o.state = "consuming"
	end
})

water_bottle=consumable:new({
	sprite = 188,
	name = "Water Bottle",
	amount = 100,
	weight = 0.8,
	consume = function(self,o,a)
		consumable.consume(self,o,a)
		o.thirst -= a
	end
})

antiseptic=consumable:new({
	sprite = 189,
	name = "Antiseptic",
	amount = 100,
	weight = 0.4,
	consume = function(self,o,a)
		consumable.consume(self,o,a)
		o.wound_health += a
	end
})

pain_killers=consumable:new({
	sprite = 191,
	name = "Painkillers",
	amount = 16,
	weight = 0.05,
	consume = function(self,o,a)
		consumable.consume(self,o,a)
		o.pain -= (a*10)
	end
})

item_types = {
	consumable = 1,
	junk = 2,
	useable = 3,
	special = 4,
	unique = 5,
}
:: main.lua
--[[pod_format="raw",created="2024-05-03 13:26:10",modified="2024-06-15 21:03:37",revision=4409]]
include './util.lua'
include './character.lua'
include './moodles.lua'
include './inventory.lua'
include './static_interactable.lua'

_debug_message = ""

function _init()
	_w_w, _w_h = 480,270
	_tile_size = 16
	c=character:new({})
	m={moodles={}}
	_flagged_tiles = {}
	debug_inv = {}
	add(debug_inv, container_slot:new({ quantity = 1, item = water_bottle:new({})}))
	add(debug_inv, container_slot:new({ quantity = 4, item = antiseptic:new({})}))
	add(debug_inv,container_slot:new({ quantity = 1, item = pain_killers:new({})}))
	i=inventory:new({contents = debug_inv})
	_containers = {}
end

function _draw()
	_m_x, _m_y, _m_b, _m_w_x, _m_w_y = mouse()
	_c_x = c.x + (_w_w/2)
	_c_y = (c.y + (_w_h/2)) - 270
	_m_x = _m_x + (_c_x - _w_w)
	_m_y = _m_y + _c_y
	_m_l_b=_m_b&1>0
	_m_r_b=_m_b&2>0
	_m_m_b=_m_b&4>0
	cls(0)
	camera(c.x - (_w_w/2),c.y - (_w_h/2))
	map()
	display_moodles(m,c)
	temp_update_tiles(i)
	animate_character(c)
	update_inventory(i)
	debug()
end

function _update()
	move_character(c)
	scan_character_area(c)
	update_character_vitals(c)
end

function debug()
	print("debug_message: " .. _debug_message
			.. " c_x: " .. _c_x
			.. " c_y: " .. _c_y, _c_x-480, _c_y+260)
end
:: moodles.lua
--[[pod_format="raw",created="2024-05-07 21:40:35",modified="2024-06-15 21:03:37",revision=3622]]
include './types.lua'
include './util.lua'

moodle=entity:new({
	moodle = "none",
	sprite = 0,
	x = 0,
	y = 0,
})

function get_index(moodles, name)
	for i, m in ipairs(moodles) do
		if m.moodle == name then
			return i
		end
	end
	return -1
end

-- moodle entity, name, value, sprite 1, 2, 3, 4, lower check
function generate_moodle(m, n, v, s1, s2, s3, s4, lc)
	index = get_index(m.moodles, n)
	current_moodle = nil
	new_sprite = -1
	if index != -1 then
		current_moodle = m.moodles[index]
	end
	if lc then
		if v >= 20 and v < 30 then
			new_sprite = s1
		elseif v >= 30 and v < 50 then
			new_sprite = s2
		elseif v >= 50 and v < 70 then
			new_sprite = s3
		elseif v >= 70 then
			new_sprite = s4
		end
	else
		if v < 70 and v >= 50 then
			new_sprite = s1
		elseif v < 50 and v >= 30 then
			new_sprite = s2
		elseif v < 30 and v >= 10 then
			new_sprite = s3
		elseif v < 10 then
			new_sprite = s4
		end
	end
	if current_moodle == nil and new_sprite != nil then
		return moodle:new({moodle=n,sprite=new_sprite})
	elseif current_moodle != nil and current_moodle.sprite != new_sprite then
		del(m.moodles,current_moodle)
		return moodle:new({moodle=n,sprite=new_sprite})
	elseif current_moodle != nil and new_sprite == nil then
		del(m.moodles,current_moodle)
		return nil
	elseif current_moodle != nil and current_moodle.sprite == new_sprite then
		del(m.moodles,current_moodle)
		return moodle:new({moodle=n,sprite=new_sprite})
	end
	return nil
end

--moodle object, character
function display_moodles(m,c)
	m.moodles = {}
	h = generate_moodle(
		m, 
		"health", 
		c.health, 
		moodle_sprites.health_1, 
		moodle_sprites.health_2, 
		moodle_sprites.health_3, 
		moodle_sprites.health_4, 
		false)
	if h.sprite > 0 then
		add(m.moodles,h)
	end

	wh = generate_moodle(
		m, 
		"wound_health", 
		c.wound_health, 
		moodle_sprites.wound_health_1, 
		moodle_sprites.wound_health_2, 
		moodle_sprites.wound_health_3, 
		moodle_sprites.wound_health_4,
		false)
	if wh.sprite > 0 then
		add(m.moodles,wh)
	end

	p = generate_moodle(
		m, 
		"pain", 
		c.pain, 
		moodle_sprites.pain_1, 
		moodle_sprites.pain_2, 
		moodle_sprites.pain_3, 
		moodle_sprites.pain_4,
		true)
	if p.sprite > 0 then
		add(m.moodles,p)
	end

	hu = generate_moodle(
		m, 
		"hunger", 
		c.hunger, 
		moodle_sprites.hunger_1, 
		moodle_sprites.hunger_2, 
		moodle_sprites.hunger_3, 
		moodle_sprites.hunger_4,
		true)
	if hu.sprite > 0 then
		add(m.moodles,hu)
	end

	t = generate_moodle(
		m, 
		"thirst", 
		c.thirst, 
		moodle_sprites.thirst_1, 
		moodle_sprites.thirst_2, 
		moodle_sprites.thirst_3, 
		moodle_sprites.thirst_4,
		true)
	if t.sprite > 0 then
		add(m.moodles,t)
	end

	d = generate_moodle(
		m, 
		"delirium",
		c.delirium,
		moodle_sprites.delirium_1, 
		moodle_sprites.delirium_2, 
		moodle_sprites.delirium_3, 
		moodle_sprites.delirium_4,
		true)
	if d.sprite > 0 then
		add(m.moodles,d)
	end
	
	current_y = 2
	for i, moodle in pairs(m.moodles) do
		spr(moodle.sprite, _c_x-18, _c_y + current_y)
		current_y += 20
	end
end

moodle_sprites={
	health_1 = 168,
	health_2 = 169,
	health_3 = 170,
	health_4 = 171,
	wound_health_1 = 160,
	wound_health_2 = 161,
	wound_health_3 = 162,
	wound_health_4 = 163,
	pain_1 = 128,
	pain_2 = 129,
	pain_3 = 130,
	pain_4 = 131,
	delirium_1 = 136,
	delirium_2 = 137,
	delirium_3 = 138,
	delirium_4 = 139,
	hunger_1 = 152,
	hunger_2 = 153,
	hunger_3 = 154,
	hunger_4 = 155,
	thirst_1 = 144,
	thirst_2 = 145,
	thirst_3 = 146,
	thirst_4 = 147,
}
:: static_interactable.lua
--[[pod_format="raw",created="2024-05-23 20:57:56",modified="2024-06-15 21:03:37",revision=2874]]
include './types.lua'
include './util.lua'

_container_id_index = 2

container=entity:new({
	max_capacity = 10,
	container_id = 2,
	small_icon = 0,
	in_range = false,
	contents = {},
})

function get_container_contents()
	local content = {}
	add(content, container_slot:new({container_id = 3, quantity = _container_id_index, item = water_bottle:new({})}))
	add(content, container_slot:new({container_id = 3, quantity = _container_id_index, item = pain_killers:new({})}))
	return content
end

-- flagged tile
function init_draws_container(ft)
	spr(5,(ft.tile_co.x*_tile_size)-1, ((ft.tile_co.y*_tile_size)))
	if table_length(_containers) > 0 then
		for i, cont in pairs(_containers) do
			if cont.x == ft.tile_co.x and cont.y == ft.tile_co.y then
				_debug_message = "tl: " .. table_length(cont.contents)
				cont.in_range = true
				return
			end
		end
	end
	draws = container:new({})
	_container_id_index += 1
	draws.container_id = _container_id_index
	draws.small_icon = 6
	draws.x, draws.y, draws.in_range = ft.tile_co.x, ft.tile_co.y, true
	draws.contents = get_container_contents()
	
	add(_containers, draws)
	return draws.container_id
end

function temp_update_tiles()
	local is_container_present = false
	for i,ft in pairs(_flagged_tiles) do
		if fget_precalc(ft.flags,1) == true then
			if ft.sprite == 4 then
				init_draws_container(ft)
				is_container_present = true
			end
		end
	end
	if not is_container_present then
		foreach(_containers, function(cont) cont.in_range = false end)
	end
	_flagged_tiles = {}
end
:: types.lua
--[[pod_format="raw",created="2024-05-06 22:22:02",modified="2024-06-15 21:03:37",revision=3541]]
class={
	new=
		function(self,tbl)
			tbl=tbl or {}
			setmetatable(tbl, {
				__index=self
				}
			)
			return tbl
		end,
}

entity=class:new({
	x=0,
	y=0,
})

container_slot=entity:new({
	container_id = 1,
	quantity = 0,
	item = nil,
	starting_x = 0,
	starting_y = 0,
	ending_x = 0,
	ending_y = 0,
})

button={
	up=4,
	down=8,
	left=1,
	right=2,
	down_right=10,
	up_left=5,
	up_right=6,
	down_left=9,
	none=0
}

direction={
	up = 1,
	down = 2,
	left = 3,
	right = 4
}
:: util.lua
--[[pod_format="raw",created="2024-05-03 22:03:54",modified="2024-06-15 21:03:37",revision=3606]]

--object, start frame,
--num frames, speed, flip
function animate_sprite(o, sf, nf, sp, fl)
	if(not o.a_la) o.a_la = sf
	if(not o.a_ct) o.a_ct = 0
	if(not o.a_st) o.a_st = 0
	if(not o.fl) o.fl = false
	o.a_ct += 1
	if o.a_ct % (30/sp) == 0 then
	 o.a_st += 1
	 if(o.a_st == nf) o.a_st = 0
	elseif o.a_la != sf then
	o.a_st = 0
	end

	o.a_fr = sf + o.a_st
	spr(o.a_fr, o.x, o.y, fl)
	o.a_la = sf
end

-- object, radius, flag
function collide(o,r,f)
	r = r or 0
	f = f or 0
	if fget2(mget((o.col_point.x/_tile_size) + r, (o.col_point.y/_tile_size)) + r,f) then
		return true
	end
	return false
end

function coalesce(a, b)
	if a == nil then
		return b
	else
		return a
	end
end

function time_since(from, to)
	return flr(to) - flr(from)
end

--tile sprite number, flag
function fget2(n, f)
	if f then
		return (fget(n)>>f)&1==1
	else
		return fget(n)
	end
end

-- pre calculated flag, flag
function fget_precalc(pcf, f)
	return (pcf>>f)&1==1	
end

function table_length(t)
	local length = 0
	for i, c in pairs(t) do
		length+=1
	end
	return length
end
:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTAzIDEzOjQ4OjQ3Iixtb2RpZmllZD0iMjAyNC0w
Ni0xNSAyMTowMzozNyIscnVudGltZT03LHdvcmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEj
MzIiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImNoYXJhY3Rlci5sdWEjMjYiLHdvcmtz
cGFjZV9pbmRleD0xfSx7bG9jYXRpb249InN0YXRpY19pbnRlcmFjdGFibGUubHVhIzIzIix3b3Jr
c3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJpbnZlbnRvcnkubHVhIzI3Iix3b3Jrc3BhY2VfaW5k
ZXg9MX0se2xvY2F0aW9uPSJpdGVtcy5sdWEjMSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlv
bj0ibW9vZGxlcy5sdWEjMTAiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InR5cGVzLmx1
YSMxIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJ1dGlsLmx1YSM1MyIsd29ya3NwYWNl
X2luZGV4PTF9LHtsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0
aW9uPSJtYXAvMC5tYXAiLHdvcmtzcGFjZV9pbmRleD0zfSx7bG9jYXRpb249InNmeC8wLnNmeCIs
d29ya3NwYWNlX2luZGV4PTR9fV1dbHo0AAQAAAADAAAAMG5pbA==
:: [eoc]
